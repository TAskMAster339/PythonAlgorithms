120) Median of Two Sorted Arrays
https://leetcode.com/problems/median-of-two-sorted-arrays/description/
Условие:
Даны два отсортированных по возрастанию массива nums1 и nums2. В массиве nums1 - m элементов, в массиве nums2 - n элементов. Нужно вернуть медиану отсортированного по возрастанию массива, полученного слиянием nums1 и nums2.
Медиана массива - число, которое находится в середине отсортированного по возрастанию массива.
Например, [1, 2, 3] -> 2 или [1, 2, 3, 4] -> 2.5 (так как середины нет, берем среднее между 2 и 3)
Алгоритм должен иметь следующую верхнюю границу по времени: O(log(m + n))
Идея:
Нужно, не сливая массивы воедино, с помощью бинарного поиска найти середину (медиану)
Реализация:
    Во-первых, рассмотрим элементарный пример: [1, 2, 3] и [4, 5, 6]. В данном случае в первом массиве наибольший элемент (3) меньше наименьшего элемента второго массива (4). Такие массивы мы можем без проблем слить ([1, 2, 3, 4, 5, 6]). Длина полученного списка будет m + n, тогда медиана будет (m + n) // 2.
    Вывод следующий: если наименьшей элемент одного из массивов больше наибольшего элемента другого, то мы можем без проблем найти медиану.
    Во-вторых, рассмотрим сложный случай. Например, [1, 3, 5] и [2, 4, 6]. Мы уже не можем просто конкатенировать данные массивы. Но воспользуемся следующей идеей.
    Сначала заметим, что результирующий массив можно разделить на два массива, которые идеально объединяются как в первом примере: [1, 2, 3, 4, 5, 6] -> [1, 2, 3] + [4, 5, 5]. Теперь наша задача - перетасовать числа в наших исходных массивах, чтобы они были расположены в порядке идеального объединения.
    Для этого разделим числа в наших массивах на две группы. В первой группе будут числа, которые попадут в левую половину объединённого массива ([1, 2, 3]), во второй группе оставшиеся числа.
    Получим два разбиения массива: [1, 3 | 5] и [2 | 4, 6]. То есть числа 1, 3 из первого массива и 2 из второго массива попадут в первую половину, другие попадут во вторую группу.
    Таким образом мы можем рассчитать медиану, потому что при объединении в центре результирующего массива будут расположены или число 3, или число 2, если (m + n) % 2 == 1. В ином случае, в центре будут два числа (3 или 2) и (4 или 5).
    В нашем случае в центре у нас будут 3 и 4, медиана будет 3.5. Получается, если длина результирующего массива четная, то медиана равна сумме максимума из двух чисел слева от палочек и минимума из двух чисел справа от палочек, разделенной на два. В ином случае медиана будет равна максимуму из двух чисел, стоящих слева от палочек.
    Осталось правильно расположить палочки. Мы будем делать это с помощью бинарного поиска. (Двигать будем до тех пор, пока не начнёт соблюдаться инвариант: максимум слева от палочек меньше минимума справа от палочек).

Оценка:
    Верхняя оценка по времени будет O(log(min(m, n))), где m, n - длина массивов nums1, nums2. (Так как в приведённом алгоритме мы делаем один бинарный поиск по наименьшему массиву).
    Верхняя оценка по памяти будет O(1).