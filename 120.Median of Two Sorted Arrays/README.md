<div align='center'>
<h1><a href='https://leetcode.com/problems/median-of-two-sorted-arrays/description/'><strong>120) Median of Two Sorted Arrays</strong></a></h1>
</div>

## **Условие:**

Даны два отсортированных по возрастанию массива **nums1** и **nums2**. В массиве **nums1** - **m** элементов, в массиве **nums2** - **n** элементов. Нужно вернуть медиану отсортированного по возрастанию массива, полученного слиянием **nums1** и **nums2**.

Медиана массива - число, которое находится в середине отсортированного по возрастанию массива.

Например, [**1**, **2**, **3**] -> **2** или [**1**, **2**, **3**, **4**] -> **2**.**5** (так как середины нет, берем среднее между **2** и **3**)

Алгоритм должен иметь следующую верхнюю границу по времени: **O**(**log**(**m** + **n**))

## **Идея:**

Нужно, не сливая массивы воедино, с помощью бинарного поиска найти середину (медиану)

## **Реализация:**

Во-первых, рассмотрим элементарный пример: [**1**, **2**, **3**] и [**4**, **5**, **6**]. В данном случае в первом массиве наибольший элемент (**3**) меньше наименьшего элемента второго массива (**4**). Такие массивы мы можем без проблем слить ([**1**, **2**, **3**, **4**, **5**, **6**]). Длина полученного списка будет **m** + **n**, тогда медиана будет (**m** + **n**) // **2**.

Вывод следующий: если наименьшей элемент одного из массивов больше наибольшего элемента другого, то мы можем без проблем найти медиану.

Во-вторых, рассмотрим сложный случай. Например, [**1**, **3**, **5**] и [**2**, **4**, **6**]. Мы уже не можем просто конкатенировать данные массивы. Но воспользуемся следующей идеей.

Сначала заметим, что результирующий массив можно разделить на два массива, которые идеально объединяются как в первом примере: [**1**, **2**, **3**, **4**, **5**, **6**] -> [**1**, **2**, **3**] + [**4**, **5**, **5**]. Теперь наша задача - перетасовать числа в наших исходных массивах, чтобы они были расположены в порядке идеального объединения.

Для этого разделим числа в наших массивах на две группы. В первой группе будут числа, которые попадут в левую половину объединённого массива ([**1**, **2**, **3**]), во второй группе оставшиеся числа.

Получим два разбиения массива: [**1**, **3** | **5**] и [**2** | **4**, **6**]. То есть числа **1**, **3** из первого массива и **2** из второго массива попадут в первую половину, другие попадут во вторую группу.

Таким образом мы можем рассчитать медиану, потому что при объединении в центре результирующего массива будут расположены или число **3**, или число **2**, если (**m** + **n**) % **2** == **1**. В ином случае, в центре будут два числа (**3** или **2**) и (**4** или **5**).

В нашем случае в центре у нас будут **3** и **4**, медиана будет **3**.**5**. Получается, если длина результирующего массива четная, то медиана равна сумме максимума из двух чисел слева от палочек и минимума из двух чисел справа от палочек, разделенной на два. В ином случае медиана будет равна максимуму из двух чисел, стоящих слева от палочек.

Осталось правильно расположить палочки. Мы будем делать это с помощью бинарного поиска. (Двигать будем до тех пор, пока не начнёт соблюдаться инвариант: максимум слева от палочек меньше минимума справа от палочек).



## **Оценка:**

Верхняя оценка по времени будет **O**(**log**(**min**(**m**, **n**))), где **m**, **n** - длина массивов **nums1**, **nums2**. (Так как в приведённом алгоритме мы делаем один бинарный поиск по наименьшему массиву).

Верхняя оценка по памяти будет **O**(**1**).

## Код:
```python
class Solution:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        if len(nums1) > len(nums2):
            return self.findMedianSortedArrays(nums2, nums1)

        m, n = len(nums1), len(nums2)
        left, right = 0, m
        while left <= right:
            partition1 = (left + right) // 2
            partition2 = (m + n + 1) // 2 - partition1

            nums1_left_max = float("-inf") if partition1 == 0 else nums1[partition1 - 1]
            nums1_right_min = float("inf") if partition1 == m else nums1[partition1]
            nums2_left_max = float("-inf") if partition2 == 0 else nums2[partition2 - 1]
            nums2_right_min = float("inf") if partition2 == n else nums2[partition2]

            if nums1_left_max <= nums2_right_min and nums2_left_max <= nums1_right_min:
                if (m + n) % 2 == 0:
                    return (
                        max(nums1_left_max, nums2_left_max)
                        + min(nums1_right_min, nums2_right_min)
                    ) / 2
                return max(nums1_left_max, nums2_left_max)
            if nums1_left_max > nums2_right_min:
                right = partition1 - 1
            else:
                left = partition1 + 1
        return None


if __name__ == "__main__":
    f = Solution().findMedianSortedArrays
    print(f([1, 3], [2]))  # 2.0
    print(f([1, 2], [3, 4]))  # 2.5
    print(f([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))  # 5.5

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/119.Find%20Minimum%20in%20Rotated%20Sorted%20Array'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/121.Kth%20Largest%20Element%20in%20an%20Array'>следующая задача ➡️</a></h3></div>