<div align='center'>
<h1><a href='https://leetcode.com/problems/number-of-islands/description/'><strong>89) Number of Islands</strong></a></h1>
</div>

## **Условие:**

Дана двумерная матрица **grid** размером **m** * **n**, которая представляет собой карту, состоящую из '**1**' (земля) и '**0**' (вода). Нужно вернуть количество островов.

Остров - это окруженная водой ('**0**') совокупность земли ('**1**') по горизонтали или вертикали. Можно предположить, что все **4** грани матрицы окружены водой

## **Идея:**

Нужно определить инвариант острова

## **Реализация:**

Переформулируем задачу следующим образом: пусть **1** - узлы графа. Если слева, справа, сверху, снизу от **1** расположена еще одна **1**, то они связаны ребром. Тогда наш остров будет представлять собой граф.

При этом можно заметить, что два разных острова будут двумя разными графами, а именно они не будут иметь ни одного общего ребра и узла.

Поэтому остается понять как посчитать количество графов в нашей матрице. Для этого нужно просто пройтись по каждой ячейки матрицы. Если она содержит **1**, то запускаем алгоритм обхода (Например **BFS**). Этот алгоритм должен пройти по всем ребрам, идущим от данной ячейки. Для того, чтобы лишний раз не ходить мы будем запоминать уже пройденные ячейки. (Их уникальным ключом будут их координаты **i** и **j**).

А теперь магия дискретной математики — сколько раз мы запустим алгоритм обхода, столько у нас и будет островов, потому что каждый вызов алгоритма обхода обойдет ровно один остров и отметит все его клетки, чтобы в следующий раз обходить другие острова.



## **Оценка:**

Верхняя граница по времени будет **O**(**N*****M**), где **N*****M** - количество ячеек матрицы, так как в наихудшем случае у нас будет один большой остров, который полностью надо будет проверить. По памяти граница такая же **O**(**N*****M**), так как мы должны запоминать все уже пройденные клетки, что не ходить по кругу.

## Код:
```python
class Solution:
    def numIslands(self, grid: list[list[str]]) -> int:
        visited = set()
        m = len(grid)
        n = len(grid[0])

        def dfs(x, y):
            queue = [(x, y)]

            while queue:
                point_x, point_y = queue.pop()
                if (point_x, point_y) in visited:
                    continue
                visited.add((point_x, point_y))
                if point_x + 1 < m and grid[point_x + 1][point_y] == "1":
                    queue.append((point_x + 1, point_y))
                if point_y + 1 < n and grid[point_x][point_y + 1] == "1":
                    queue.append((point_x, point_y + 1))
                if point_x - 1 >= 0 and grid[point_x - 1][point_y] == "1":
                    queue.append((point_x - 1, point_y))
                if point_y - 1 >= 0 and grid[point_x][point_y - 1] == "1":
                    queue.append((point_x, point_y - 1))

        count = 0

        for j in range(n):
            for i in range(m):
                if grid[i][j] == "1" and (i, j) not in visited:
                    dfs(i, j)
                    count += 1

        return count




if __name__ == "__main__":
    s = Solution()
    print(s.numIslands(
        [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"],
        ],
    ))
    print(s.numIslands(
        [
        ["1","1","0","0","0"],
        ["1","1","0","0","0"],
        ["0","0","1","0","0"],
        ["0","0","0","1","1"],
        ],
    ))
    print(s.numIslands(
        [
        ["1","1","1"],
        ["0","1","0"],
        ["1","1","1"],
        ],
    ))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/88.Validate%20Binary%20Search%20Tree'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>
