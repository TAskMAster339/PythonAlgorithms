# [**66) Partition List**](https://leetcode.com/problems/partition-list/description/)

## **Условие:**

Дан указатель на начало односвязного списка **head** и значение **x**, нужно разбить список так, чтобы все узлы, значение которых меньше **x**, были в списке раньше всех узлов, значение которых больше или равно **x**.

При этом нужно сохранить исходный порядок узлов в списке.

## **Идея:**

Бинарное дерево.

## **Реализация:**

Создадим две болванки **less** и **more**, к которым мы будем приклеивать узлы, которые меньше или больше, чем **x**. Затем в цикле мы проходим по всем узлам, создаем их копии и присоединяем их к соответствующим спискам. (Можно не создавать копии, но при этом нужно будет учесть, что может возникнуть ссылка на саму себя). Затем остается грамотно объединить полученные списки в один и вернуть его. Так как эти списки были получены одним прямым проходом по исходному списку, то мы можем гарантировать, что порядок элементов будет сохранён.



## **Оценка:**

По времени мы затратим **O**(**N**), так как проходим по списку длинной **N**. По памяти мы затратим **O**(**N**), так как создаем копию каждого узла. Можно сократить до **O**(**1**), если разобраться с ссылками. Но я выбрал копирование, так как это гарантирует, что мы получаем новый уникальный объект. (Его нельзя будет менять с помощью изначального списка, что очень надежно).

