<div align='center'>
<h1><a href='https://leetcode.com/problems/combination-sum/description/'><strong>104) Combination Sum</strong></a></h1>
</div>

## **Условие:**

Дан массив уникальных чисел **candidates** и число **target**, нужно вернуть список уникальных комбинаций чисел из массива **candidates**, где сумма выбранных чисел равна **target**.

Одно и то же число из массива **candidates** может использоваться неограниченное количество раз. Две комбинации называются уникальными, если частота хотя бы одного элемента отличается

## **Идея:**

Вся сложность - придумать как собирать только уникальные комбинации

## **Реализация:**

Идем по той же идеи с рекурсивным **backtrack**.

Крайний случай будет состоять из двух частей: **1**) Если сумма чисел в комбинации будет больше **target**, то возвращаемся. **2**) Если сумма равна **target**, то записываем копию комбинации в **result**.

В рекуррентном случае мы проходим по всем числам из **candidates**, добавляя **i**-тое число в комбинацию, вызывая **backtrack** с новой суммой, и не забываем про возврат.

Таким образом мы получим все возможные комбинации чисел, сумма которых равна **target**. Но у нас будут еще все перестановки данных чисел. А нам нужны только уникальные пары.

Для этого мы воспользуемся следующей идеей. Мы будем перебирать сначала все возможные комбинации нашим алгоритмом, используя все числа из **candidates**. В следующий раз мы уберем первый элемент из массива. Такое действие гарантирует нам, что мы, перебирая все комбинации среза **candidates**[**1**:], получим, что все эти пары будут уникальны. Потому что частота убранного нами элемента в этих комбинациях будет равна **0**. А в предыдущих комбинациях, так как они все будут начинаться с убранного числа, то частота этого числа будет всегда больше или равна **1**. Таким подходом мы добились уникальности комбинаций.

Реализуем это с помощью добавление еще одного параметра **level** к функции **backtrack**. Этот параметр будет ограничивать цикл **for** по **candidates** снизу. При вызове **backtrack** в **level** будем передавать индекс элемента. Это неявным образом создаст выше описанный срез.



## **Оценка:**

Оценка по времени будет равна **O**(**N**^**K**), где **N** - длина массива **candidates**, а **K** - максимальная длина комбинации, она будет в наихудшем случае равна отношению **target** к **min**(**candidates**). Например, если минимальное число в массива равно **1**, то длина комбинации в наихудшем случае будет **target**. Наш алгоритм в этом случае будет вынужден проверить все **N**^**target** перестановок.

По памяти в наихудшем случае мы получим **O**(**K**). Так как в наихудшем случае у нас будет заполнен **K** элементами массив **comb**. И стек глубины вызовов будет тоже **O**(**K**). Они не зависят, поэтому итого получаем **O**(**K**).

## Код:
```python
class Solution:
    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:
        result = []

        def backtrack(comb: list[int], summary: int, level: int):
            if summary > target:
                return
            if summary == target:
                result.append(comb[:])
                return
            for i in range(level, len(candidates)):
                comb.append(candidates[i])
                backtrack(comb, summary + candidates[i], i)
                comb.pop()

        backtrack([], 0, 0)
        return result


if __name__ == "__main__":
    f = Solution().combinationSum
    print(f([2, 3, 6, 7], 7))
    print(f([2, 3, 5], 8))
    print(f([2], 1))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/103.Permutations'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>