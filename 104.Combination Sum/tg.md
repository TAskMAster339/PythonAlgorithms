**104) Combination Sum**
https://leetcode.com/problems/combination-sum/description/
**Условие:**
Дан массив уникальных чисел **candidates** и число **target**, нужно вернуть список уникальных комбинаций чисел из массива **candidates**, где сумма выбранных чисел равна **target**.
Одно и то же число из массива **candidates** может использоваться неограниченное количество раз. Две комбинации называются уникальными, если частота хотя бы одного элемента отличается
**Идея:**
Вся сложность - придумать как собирать только уникальные комбинации
**Реализация:**
    Идем по той же идеи с рекурсивным **backtrack**.
    Крайний случай будет состоять из двух частей: **1**) Если сумма чисел в комбинации будет больше **target**, то возвращаемся. **2**) Если сумма равна **target**, то записываем копию комбинации в **result**.
    В рекуррентном случае мы проходим по всем числам из **candidates**, добавляя **i**-тое число в комбинацию, вызывая **backtrack** с новой суммой, и не забываем про возврат.
    Таким образом мы получим все возможные комбинации чисел, сумма которых равна **target**. Но у нас будут еще все перестановки данных чисел. А нам нужны только уникальные пары.
    Для этого мы воспользуемся следующей идеей. Мы будем перебирать сначала все возможные комбинации нашим алгоритмом, используя все числа из **candidates**. В следующий раз мы уберем первый элемент из массива. Такое действие гарантирует нам, что мы, перебирая все комбинации среза **candidates**[**1**:], получим, что все эти пары будут уникальны. Потому что частота убранного нами элемента в этих комбинациях будет равна **0**. А в предыдущих комбинациях, так как они все будут начинаться с убранного числа, то частота этого числа будет всегда больше или равна **1**. Таким подходом мы добились уникальности комбинаций.
    Реализуем это с помощью добавление еще одного параметра **level** к функции **backtrack**. Этот параметр будет ограничивать цикл **for** по **candidates** снизу. При вызове **backtrack** в **level** будем передавать индекс элемента. Это неявным образом создаст выше описанный срез.

**Оценка:**
    Оценка по времени будет равна **O**(**N**^**K**), где **N** - длина массива **candidates**, а **K** - максимальная длина комбинации, она будет в наихудшем случае равна отношению **target** к **min**(**candidates**). Например, если минимальное число в массива равно **1**, то длина комбинации в наихудшем случае будет **target**. Наш алгоритм в этом случае будет вынужден проверить все **N**^**target** перестановок.
    По памяти в наихудшем случае мы получим **O**(**K**). Так как в наихудшем случае у нас будет заполнен **K** элементами массив **comb**. И стек глубины вызовов будет тоже **O**(**K**). Они не зависят, поэтому итого получаем **O**(**K**).
