<div align='center'>
<h1><a href='https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/'><strong>101) Letter Combinations of a Phone Number</strong></a></h1>
</div>

## **Условие:**

Дана строка **digits**, которая содержит цифры от **2** до **9** включительно, нужно вернуть все возможные комбинации буковок, которые может из себя представлять набранная последовательность цифр.

Буковки соответствуют цифрам, как на старом кнопочном телефоне, смотри скрин

## **Идея:**

Тупой перебор, только немного оптимизируем с помощью возврата (**backtracking**)

## **Реализация:**

Для начала создадим словарь, где ключ - цифра, а строка - буквы, которые можно набрать, нажимая на эту цифру.

Создадим вспомогательную функцию **backtrack**, которая будет принимать номер цифры в строке **digits** и список. В рекуррентном случае мы будем проходить по всем символам строки, взятой из словаря, по ключу цифры. Сначала будем добавлять символ в список. Затем вызывать **backtrack** для следующей цифры в строке **digits**. После того как он закончиться мы убираем цифру из списка (Вот это - так называемый **backtrack**). В крайнем случае мы проверяем длину списка и длину строки **digits**, если они равны, то мы объединяем символы списка в строку и записываем в **result**. В конце мы его возвращаем.



## **Оценка:**

Верхняя оценка по времени будет **O**(**4**^**N**), где **N** - длина строки **digits**. Появляется она из следующих соображений: нам дана строка длинной **N**, нам нужно вернуть массив строк, длины которых равны **N**. Каждая строка будет получена с помощью **backtrack**, сложность которого **O**(**1**). Поэтому итоговая сложность будет равна **O**(**1**) * количество элементов в массиве. Для того чтобы посчитать это количество вспомним комбинаторику, у нас есть **N** позиций, в каждую из которых мы можем поставить один из **3**-**4** символов (Для оценки в наихудшем случае будем брать максимум, то есть **4**). Количество таких комбинаций будет равно **4**^**N**. Итого, сложность равна **O**(**1**) * **O**(**4**^**N**) = **O**(**4**^**N**).

Верхняя асимптотическая граница по памяти будет **O**(**N**). Дополнительной памяти мы не используем (На словарь уйдет **O**(**1**)), но у нас будут невидимые расходы на стек. В наихудшем случае функция **backtrack** будет вызвана **N** раз, потому что длина слова равняется **N**, за одну итерацию мы ставим одну букву на место. Отсюда получается верхняя граница - **O**(**N**).

## Код:
```python
class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        if not digits:
            return []
        mapping = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }
        result = []

        def backtack(num: int, word: list[str]):
            if len(word) == len(digits):
                result.append("".join(word))
                return
            for char in mapping[digits[num]]:
                word.append(char)
                backtack(num + 1, word)
                word.pop()

        backtack(0, [])
        return result


if __name__ == "__main__":
    f = Solution().letterCombinations
    print(f("23"))
    print(f(""))
    print(f("2"))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/100.Word%20Search%20II'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/102.Combinations'>следующая задача ➡️</a></h3></div>