101) Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/
Условие:
Дана строка digits, которая содержит цифры от 2 до 9 включительно, нужно вернуть все возможные комбинации буковок, которые может из себя представлять набранная последовательность цифр.
Буковки соответствуют цифрам, как на старом кнопочном телефоне, смотри скрин
Идея:
Тупой перебор, только немного оптимизируем с помощью возврата (backtracking)
Реализация:
    Для начала создадим словарь, где ключ - цифра, а строка - буквы, которые можно набрать, нажимая на эту цифру.
    Создадим вспомогательную функцию backtrack, которая будет принимать номер цифры в строке digits и список. В рекуррентном случае мы будем проходить по всем символам строки, взятой из словаря, по ключу цифры. Сначала будем добавлять символ в список. Затем вызывать backtrack для следующей цифры в строке digits. После того как он закончиться мы убираем цифру из списка (Вот это - так называемый backtrack). В крайнем случае мы проверяем длину списка и длину строки digits, если они равны, то мы объединяем символы списка в строку и записываем в result. В конце мы его возвращаем.

Оценка:
    Верхняя оценка по времени будет O(4^N), где N - длина строки digits. Появляется она из следующих соображений: нам дана строка длинной N, нам нужно вернуть массив строк, длины которых равны N. Каждая строка будет получена с помощью backtrack, сложность которого O(1). Поэтому итоговая сложность будет равна O(1) * количество элементов в массиве. Для того чтобы посчитать это количество вспомним комбинаторику, у нас есть N позиций, в каждую из которых мы можем поставить один из 3-4 символов (Для оценки в наихудшем случае будем брать максимум, то есть 4). Количество таких комбинаций будет равно 4^N. Итого, сложность равна O(1) * O(4^N) = O(4^N).
    Верхняя асимптотическая граница по памяти будет O(N). Дополнительной памяти мы не используем (На словарь уйдет O(1)), но у нас будут невидимые расходы на стек. В наихудшем случае функция backtrack будет вызвана N раз, потому что длина слова равняется N, за одну итерацию мы ставим одну букву на место. Отсюда получается верхняя граница - O(N).