<div align='center'>
<h1><a href='https://leetcode.com/problems/snakes-and-ladders/description/'><strong>95) Snakes and Ladders</strong></a></h1>
</div>

## **Условие:**

Дана матрица целых чисел **board** размером **n** на **n**, каждая клетка матрицы отмечена числом от **1** до **n**^**2** в порядке зигзага, начиная с левого нижнего угла.

Вы начинаете с **1** клетки. Чтобы сделать ход вы бросаете кубик, следующая клетка лежит в таком диапазоне [**current** + **1**, **min**(**current** + **6**, **n**^**2**)], где **current** - текущая клетка.

Также на доске есть клетки с лестницами и змеями. Если вы попадаете на такую клетку, то вы перемещаетесь по лестнице или по змее.

Необходимо вернуть минимальное количество бросков кубика, которых хватит, чтобы дойти до клетки под номером **n**^**2**. Если это невозможно, верните -**1**

## **Идея:**

Эту игру можно представить в виде графа, тогда решение - поиск наикратчайшего пути в графе.

## **Реализация:**

В начале создадим массив **dist** размером **n**^**2** + **1**, в котором по **i**-тому индексу мы будем хранить наименьшие количество бросков кубика, чтобы достигнуть **i**-той ячейки. По умолчанию заполним -**1**.

Для начала запишем значение **0** в стартовую ячейку и добавим эту ячейку в очередь.

С помощью очереди реализуем **BFS**. Достаем нашу клетку из очереди и рассматриваем следующие возможные **6** клеток для хода. Мы рассчитываем индексы следующей клетки в матрице и с помощью этого вычисляем значение, которое лежит в следующей клетке. Если оно не равно -**1**, то мы попали на лестницу или змею, значит мы при ходе в эту клетку поднимаемся по лестнице или спускаемся по змее. С помощью этого значение, если мы еще не знаем путь в эту клетку, то записываем в **dist**[**move**] = **dist**[**current**] + **1**. И добавляем клетку **move** в очередь.

В конце остается проверить является ли **current** клетка искомой, если да, то возвращаем **dist**[**current**].

(Если интересно, почему такой путь будет всегда наикратчайшим (с наименьшим количеством бросков кубика), то посмотрите на алгоритм Дейкстры, я неявно использовал его правило).



## **Оценка:**

Верхняя граница по времени будет **O**(**N**^**2**), потому что мы пройдем по всем клеткам доски, чтобы посчитать все возможные пути. По памяти мы будет хранить массив **dist**, который имеет размер **N**^**2** + **1**, поэтому асимптотическая оценка по памяти будет **O**(**N**^**2**).

## Код:
```python
from collections import deque


class Solution:
    def snakesAndLadders(self, board: list[list[int]]) -> int:
        n = len(board)
        target = n**2
        dist = [-1] * (target + 1)
        start = 1
        dist[start] = 0
        queue = deque([start])

        while queue:
            current = queue.popleft()
            for i in range(1, 7):
                next = current + i
                if next > target:
                    break

                row = (next - 1) // n
                col = (next - 1) % n
                value = board[n - 1 - row][(n - 1 - col) if (row % 2 == 1) else col]
                move = value if value > 0 else next

                if move == target:
                    return dist[current] + 1

                if dist[move] == -1:
                    dist[move] = dist[current] + 1
                    queue.append(move)
        return -1


if __name__ == "__main__":
    f = Solution().snakesAndLadders
    print(
        f(  # 4
            [
                [-1, -1, -1, -1, -1, -1],
                [-1, -1, -1, -1, -1, -1],
                [-1, -1, -1, -1, -1, -1],
                [-1, 35, -1, -1, 13, -1],
                [-1, -1, -1, -1, -1, -1],
                [-1, 15, -1, -1, -1, -1],
            ],
        ),
    )
    print(f([[-1, -1], [-1, 3]]))  # 1

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/94.Course%20Schedule%20II'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>