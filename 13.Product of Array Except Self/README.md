# [**13) Product of Array Except Self**](https://leetcode.com/problems/product-of-array-except-self/description/)

## **Условие:**

Дан массив чисел **nums**, нужно вернуть массив **answer**, такой, что **answer**[**i**] равняется произведению всех чисел массива **nums**, за исключением самого **nums**[**i**]

Идея: пусть у нас есть массив **a**, который состоит из **3** элементов. Тогда искомое произведение для **a**[**2**] = **a**[**1**] * **a**[**3**]. С помощью этого частного случая нужно вывести формулу для **a**[**k**].

Рассмотрим значение **a**[**k**], оно будет равно **a**[**k**] = (**a**[**i**] * **a**[**i** - **1**] * **a**[**i** - **2**] * . . . * **a**[**0**]) * (**a**[**j**] * **a**[**j** + **1**] * **a**[**j** + **2**] * . . . * **a**[**len**(**a**) - **1**]), где **i** < **k** < **j**. Обозначив первое произведение за **A**[**k** - **1**], а второе за **B**[**k** + **1**], получим **a**[**k**] = **A**[**k** - **1**] * **B**[**k** + **1**]

В общем и целом, вывод вот этой формулы и есть решение задачи. Теперь остается реализовать эту формулу. Самой просто метод - создать два массива, один будет содержать префиксные произведения с начала массива(первый, первый * второй, первый * второй * третий, и тд.), другой те же префексный произведения, только с конца.

Затем создем массив **answer** и за один проход заполняем его, используя ранее выведенную формулу. Только обязательно нужно не забыть обработать крайние случаи (выходы за границы массива).

В итоге, для того чтобы посчитать два массива префиксных произведений мы затратим **O**(**N**) времени, чтобы рассчитать массив **answer** потратим тоже **O**(**N**), итого общее затраченное время - **O**(**N**). Единственный минус данного решение - это память мы потратим **O**(**N**), этого можно избежать, если в начале создать массив **answer**, далее в него нужно записать префиксное произведение от начала массива. Затем обратным проходом по массиву **nums**, динамически считать префиксное произведение с конца, аккуратно сливая его с уже посчитанным произведением в массиве **answer**.

## Код:
```python
from typing import List


class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        prefix = [0] * len(nums)
        prefix[0] = nums[0]
        suffix = [0] * len(nums)
        suffix[-1] = nums[-1]

        for i in range(1, len(nums)):
            prefix[i] = prefix[i - 1] * nums[i]

        for i in range(len(nums) - 2, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i]

        result = [0] * len(nums)
        for i in range(len(nums)):
            if i + 1 == len(nums):
                result[i] = prefix[i - 1]
            elif i == 0:
                result[i] = suffix[i + 1]
            else:
                result[i] = suffix[i + 1] * prefix[i - 1]
        return result


if __name__ == "__main__":
    s = Solution()
    print(s.productExceptSelf([1, 2, 3, 4]))
    print(s.productExceptSelf([-1, 1, 0, -3, 3]))

```

### [<-- предыдущая задача](https://github.com/TAskMAster339/PythonAlgorithms/tree/main/12.Insert%20Delete%20GetRandom%20O(1)) | [следующая задача -->](https://github.com/TAskMAster339/PythonAlgorithms/tree/main/14.Gas%20Station)
