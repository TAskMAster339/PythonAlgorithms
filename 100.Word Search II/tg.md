**100) Word Search II**
https://leetcode.com/problems/word-search-ii/description/
**Условие:**
Дана доска **board** размером **m** на **n**, заполненная буквами. Также есть список строк **words**, нужно вернуть все слова, которые есть на доске.
Слово присутствует на доске, если оно может быть составлено с помощью последовательности букв в примыкающих клеточках. Клеточки примыкаются, если они расположены по соседству по горизонтали или по вертикали. Одна и та же клеточка не может использоваться больше одного раза в слове. Смотрите фоточку
**Идея:**
Представить в виде графа и пройтись **DFS**, только нужно оптимизировать, иначе будет очень долго
**Реализация:**
    Реализуем структуру данных **Trie**, которая была реализована в предыдущих задачах. Заполним её словами из списка **words**. И дальше реализуем **DFS**.
    **DFS** будет принимать строку, столбец, слово и множество уже посещенных вершин.
    Если пара строка, столбец уже проходились, то мы возвращаемся. Иначе добавляем эту пару в множество. Так же тут мы воспользуемся деревом префиксов для оптимизации. Если наше нынешнее слово не является префиксом в дереве, то можно смело возвращаться, так как это значит, что мы его уже не найдем. Если наше нынешнее слово есть в дереве, значит мы нашли его, записываем в **result**, который вернем в конце, а уже найденное слово удаляем из **Trie**.
    В самом **DFS** мы будем запускать еще **4** **DFS** для всех возможных направлений (вверх, вниз, влево, вправо).  
    В конце нам осталось вызвать наш **DFS**, начиная с каждой клетки доски.
    Важный момент - это заполнения множества **visited**. Мы должны в нем хранить только те клетки, буквы которых составляют наше слово! То есть мы еще должны учесть логику удаления из множества. Самый простой способ сделать это через постоянное копирование **visited**, но это дорого по памяти. Лучше всего использовать стек.

**Оценка:**
    Верхняя оценка по времени будет **O**(**NM*****4**^**L**), где **N** - количество строк в доске, **M** - количество столбцов в доске, **L** - средняя длина слова в **words**. Она получается следующим образом. Для каждой клетки доски, которых всего **NM**, будет вызван **DFS**, который будет пытаться построить слово длиной **L**, двигаясь в **4** стороны. Поэтому в наихудшем случае **DFS** будет выполнять **4**^**L** операций. У нас в задаче **L** <= **10**. Хотя средняя длина слова будет всегда меньше.
    Верхняя оценка по памяти будет равна **O**(**LK**), где **L** - средняя длина слова, а **K** - количество слов в **words**. Столько памяти мы расходуем на хранение **Trie**. Также есть накладные расходы на стек вызова. Но они тоже будут в наихудшем случае **O**(**LK**).
