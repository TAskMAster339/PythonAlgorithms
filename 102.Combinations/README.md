<div align='center'>
<h1><a href='https://leetcode.com/problems/combinations/description/'><strong>102) Combinations</strong></a></h1>
</div>

## **Условие:**

Даны два числа **n** и **k**, нужно вернуть все возможные сочетания из **n** по **k** чисел в диапазоне [**1**, **n**]

## **Идея:**

Вспомнить, что такое сочетания

## **Реализация:**

Создадим вспомогательную рекурсивную функцию **backtrack**, которая будет с помощью возврата вычислять сочетания и заполнять массив **comb**.

В крайнем случае (когда длина **comb** равна **k**), то мы записываем в массив **result** копию массива **comb** (Важно копировать, иначе мы положим ссылку)

В рекуррентном случае мы будем в цикле добавлять добавлять числа в массив **comb**, затем вызывать **backtrack**, от **i** + **1**. После не забываем про откат последнего вставленного числа в массив. Число **i** + **1** я назвал **level**, так как он ограничивает диапазон числе от **1** до **n** + **1** снизу. Эта хитрость позволит динамически менять диапазон, что не позволит составить сочетания с одинаковыми числами (Это бы славно было бы доказать).



## **Оценка:**

Верхняя оценка по времени будет **O**(**K** * **C**(**n**, **k**)), где **K** - длина числа. Так как в наихудшем случае нам нужно будет рассчитать все сочетание всего их будет **C**(**n**, **k**). Когда мы посчитаем одно из чисел, мы будем делать копию массива. Это операция стоит **O**(**K**), её нам нужно будет делать все **C**(**n**, **k**) раз.

Верхняя оценка по памяти **O**(**K**), потому что из-за расходов на стек вызовов, мы затратим **O**(**K**), где **K** - длина слова. (Также мы будем хранить массив **comb**, для хранения комбинаций, что тоже будет **O**(**K**), но в итоге получим **O**(**K**) + **O**(**K**) = **O**(**K**)).

## Код:
```python
class Solution:
    def combine(self, n: int, k: int) -> list[list[int]]:
        result = []

        def backtrack(level: int, comb: list[int]):
            if len(comb) == k:
                result.append(comb[:])
                return
            for i in range(level, n + 1):
                comb.append(i)
                backtrack(i + 1, comb)
                comb.pop()

        backtrack(1, [])
        return result


if __name__ == "__main__":
    f = Solution().combine
    print(f(4, 2))
    print(f(1, 1))
    print(f(3, 3))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/101.Letter%20Combinations%20of%20a%20Phone%20Number'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>