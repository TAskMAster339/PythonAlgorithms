102) Combinations
https://leetcode.com/problems/combinations/description/
Условие:
Даны два числа n и k, нужно вернуть все возможные сочетания из n по k чисел в диапазоне [1, n]
Идея:
Вспомнить, что такое сочетания 
Реализация:
    Создадим вспомогательную рекурсивную функцию backtrack, которая будет с помощью возврата вычислять сочетания и заполнять массив comb.
    В крайнем случае (когда длина comb равна k), то мы записываем в массив result копию массива comb (Важно копировать, иначе мы положим ссылку)
    В рекуррентном случае мы будем в цикле добавлять добавлять числа в массив comb, затем вызывать backtrack, от i + 1. После не забываем про откат последнего вставленного числа в массив. Число i + 1 я назвал level, так как он ограничивает диапазон числе от 1 до n + 1 снизу. Эта хитрость позволит динамически менять диапазон, что не позволит составить сочетания с одинаковыми числами (Это бы славно было бы доказать).

Оценка:
    Верхняя оценка по времени будет O(K * C(n, k)), где K - длина числа. Так как в наихудшем случае нам нужно будет рассчитать все сочетание всего их будет C(n, k). Когда мы посчитаем одно из чисел, мы будем делать копию массива. Это операция стоит O(K), её нам нужно будет делать все C(n, k) раз.
    Верхняя оценка по памяти O(K), потому что из-за расходов на стек вызовов, мы затратим O(K), где K - длина слова. (Также мы будем хранить массив comb, для хранения комбинаций, что тоже будет O(K), но в итоге получим O(K) + O(K) = O(K)).