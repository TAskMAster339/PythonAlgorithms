17) Roman to Integer
https://leetcode.com/problems/roman-to-integer/description/
Условие:
     Дано римское число, нужно перевести его в нормальное.
Идея:
     Хэш-таблица.
Реализация:
     Создадим словарь table, где ключами будут римские цифры, а значениями их значение в арабских цифрах. ("I": 1, "V": 5 и так далее) Создадим переменную prev, в которой будем хранить предыдущую римскую цифру, это нужно для случаев IV, IX и подобных. В этих случаях нам нужно из большей цифры вычесть меньшую. Инициализируем prev первой римской цифрой. Создаем переменную result, которую инициализируем table[prev], арабское значение римской цифры.
     Далее проходим циклом по римским цифрам, динамически высчитывая result. Нужно учесть ранее упомянутый случай, когда table[s[i]] > table[prev], в этом случае мы из result вычитаем table[prev] (так как оно зря было добавлено в result, на предыдущей итерации) и добавляем table[s[i]] - table[prev]. Если римская цифра меньше или равна предыдущей, то мы просто прибавляем её значение в result. Также не забываем обновлять значение prev в конце каждой итерации.
     После окончания цикла в переменной result будет записано искомое число, его мы и возвращаем. 
     
Оценка:
     По времени мы потратим O(N), по памяти O(1), так как у нас существует ограниченное количество римских цифр (7 всего), поэтому её размер будет константным, или можно показать, что её размер никак не зависит от N, в обоих случаях получаем постоянную память. На самом деле можно еще лучше оптимизировать алгоритм, заменив хэш-таблицу двумя массивами, у которых по соответствующим индексам будут находится римская цифра и её значение. (["I", "V", ...] [1, 5, ...]). Тем самым мы получим ту же самую хэш-таблицу, только данная реализация гарантирует в наихудшем случае доступ к элементам O(1), что оптимизирует время, а отсутствие накладных расходов на реализацию хэш-таблицы(Разрешение коллизии, ...) мы сэкономим память.