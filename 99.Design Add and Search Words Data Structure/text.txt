99) Design Add and Search Words Data Structure
https://leetcode.com/problems/design-add-and-search-words-data-structure/description/
Условие:
Создайте дизайн структуры данных, которая поддерживает добавления новых слов и поиск, ранее вставленного слова.
Реализуйте класс WordDictinary, который имеет конструктор, метод void addWord(word), который добавляет слово в структуру данных, метод bool search(word). Возвращает True, если в структуре есть слово, которое подходит под паттерн word. Паттерн word может содержать точки ".", которая может принимать значения любого символа. Например под паттерн "d.g" подходит "dog", "dug", "dig" и т.д.
Идея:
Реализовать Trie и воспользоваться DFS
Реализация:
    По аналогии с предыдущей задачей создадим класс TrieNode. В конструкторе объекта создадим корень root = TrieNode()
    Метод добавления будет точно такой же, как и в Trie.
    Метод поиска уже поинтересней. Создадим внутреннюю функцию DFS, которая будет рекурсивно искать слово в нашем Trie. Аргументами функции будут выступать node и level. Node - узел дерева, level - глубина на которую мы спустились.
    Крайним случаем выступит ситуация, когда level = len(word), возвращаем node.is_end.
    В рекуррентном случае у нас 2 варианта действия. Если символ (word[level]) оказался точкой, то нам не повезло и мы должны проверить всех детей нашего узла. Для каждого ребенка вызываем dfs(child, level+1). Возвращаем any() от этих вызовов. Если нам повезло, то мы проверяем есть ли символ в дочерних узлах, если нет, то возвращаем False, иначе вызываем dfs для следующего узла.
    Не забываем в функции поиска вернуть dfs(self.root, 0)

Оценка:
    По времени вставка будет выполнена за O(N), где N - длина слова. Поиск слова будет выполняться в наихудшем случае за O(K^T * N), где K - мощность алфавита или максимальное количество детей у узла, T - количество точек в строке. Но амортизационная оценка будет O(N), так как наш поиск ищет какой-либо путь от корня к листу. Это расстояние будет глубиной дерева, в нашем случае она будет равна N. По памяти мы затратим O(NM), где M - количество слов, которые надо хранить.