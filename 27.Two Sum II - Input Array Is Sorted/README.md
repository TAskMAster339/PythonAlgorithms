# [**27) Two Sum II - Input Array Is Sorted**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

## **Условие:**

Дан массив целых чисел **numbers**, в котором индексация начинается с **1**. Он отсортирован в неубывающем порядке. Нужно найти два числа, таких, что их сумма совпадает с заданным числом **target**. Нужно вернуть индексы этих чисел, в виде массива [**index1**, **index2**], где **1** <= **index1** < **index2** <= **len**(**numbers**). Гарантируется единственное решение. Нельзя использовать одно число дважды. Решение должно использовать константное количество памяти (**O**(**1**)).

## **Идея:**

Самая простая задача на два указателя.

## **Реализация:**

Метод двух указателей состоит в том, что мы идем по массиву, используя два каких-либо указателя. Алгоритм их движения мы выбираем в зависимости от задачи.

Для начала создадим два указателя. **first** = **0** и **second** = **len**(**numbers**) - **1**. Первый указывает на начало массива, второй на конец. Такое расположение обусловлено тем, что наш входной массив отсортирован по неубыванию. Этот факт позволяет расположить указатели в начале и в конце списка, так как мы будем работать с суммой чисел, расположенных по этим указателям. (Первый указывает на самое маленькое число в массиве, второй на самое большое.)

Отсюда становиться очевидна логика их движения. Если сумма чисел будет больше таргета, то встает вопрос как нам её уменьшить? Очевидно, сдвинув, второй указатель влево на **1**.(Так как последовательность неубывающая, то предыдущие число будет либо меньше либо равно нынешнему) Поэтому только так мы можем уменьшить сумму. А если наша сумма меньше таргета, то её нужно увеличить, поэтому мы инкрементируем первый указатель. (следующие число будет больше предыдущего)

Как только сумма станет равна таргету, возвращаем массив из двух наших указателей.



## **Оценка:**

Если пойти методом грубой силы, то для подсчета пар, чья сумма равна таргету, мы потратим **O**(**N**^**2**) (В наихудшем случае придется перебрать **N** * (**N** - **1**) пар чисел). Но используя два указателя, мы в наихудшем случае пройдем (**N** - **1**) чисел, что говорит о временной асимптотике равной **O**(**N**). Память **O**(**1**), так как мы храним только два числа, наши указатели.

## Код:
```python
from typing import List


class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        first = 0
        second = len(numbers) - 1
        while True:
            if numbers[first] + numbers[second] < target:
                first += 1
            elif numbers[first] + numbers[second] > target:
                second -= 1
            else:
                return [first + 1, second + 1]


if __name__ == "__main__":
    s = Solution()
    print(s.twoSum([2, 7, 11, 15], 9))
    print(s.twoSum([2, 3, 4], 6))
    print(s.twoSum([-1, 0], -1))
    print(s.twoSum([5, 25, 75], 100))

```

### [<-- предыдущая задача](https://github.com/TAskMAster339/PythonAlgorithms/tree/main/26.Is%20Subsequence) | [следующая задача -->](https://github.com/TAskMAster339/PythonAlgorithms/tree/main/28.Container%20With%20Most%20Water)
