**18) Integer to Roman**
https://leetcode.com/problems/integer-to-roman/description/
**Условие:**
Дано число, нужно записать его римскими цифрами.
**Идея:**
Хэш-таблица. Ну еще знание как работают римские цифры.
**Реализация:**
     Аналогично предыдущей задачи создадим хэш-таблицу **table**, только теперь ключами будут числа **1000**, **900**, **500**, ... , а ключами будут римские цифры которые используются для их представления. Также создадим строку **result**, в которую будем записывать римские цифры.
     Здесь идеально подходит жадный алгоритм.
 
     Для справки жадный алгоритм - разновидность динамических алгоритмов, отличается тем, что мы можем разделить всю задачу на одну  элементарную задачу, полученную и решенную жадным выбором, и оставшиеся задачи, которые тоже можно разделить и решить жадным выбором. Вообще хорошая практика делать динамическое решение и уже только потом оптимизировать его до жадного, потому что существуют некоторые задачи, которые якобы хороши для жадного решения, но на самом деле жадно не решаются (задача с рюкзаком). 
     Условия, при которых мы можем воспользоваться жадным алгоритмом
**1**) есть жадный выбор (делим задачи на **1** особую и другие оставшиеся)
**2**) Все задачи независимы друг от друга. (Иначе жадный выбор не даст правильный ответ)
**3**) Решение задачи - совокупность жадных выборов в подзадачах (Результат жадного выбора всегда идет в ответ). 
     Ключевое отличие жадного подхода от динамического состоит в том, что в динамическом программирование мы решаем динамически решаем зависимые подзадачи, таким образом приходя к объединенному решению, мы двигаемся снизу вверх (подзадача -> задача). При жадном подходе мы сразу решаем полную задачу, её решение = жадный выбор + жадное решение, образованной подзадачи, которая решается жадно. При жадном подходе мы двигаемся сверху вниз (задача -> подзадача).

     Теперь перейдем к практике. В хэш-таблицы ключи располагаются в убывающем порядке, это пригодится для жадного выбора. С помощью цикла **for**, который перебирает ключи словаря **table**, мы будем делать жадный выбор, то есть мы будем делить нашу задачу на две, первая задача будет уже решена жадным выбором наибольшей римской цифрой, для записи этого числа, а вторая будет решаться аналогично жадно. Например, **num** = **1001**, делаем жадный выбор получаем **result** = "**M**" + жадное выбор для **num** = **1** ("**I**"). Получим ответ **result** = "**MI**". Все решение заключается в том, чтобы искать наибольшей из ключей нашей хэш-таблицы, вычитать его из числа **num**, до тех пор пока будем получать положительный результат, при этом каждый раз записывая в **result** += **table**[**i**], значение этого ключа. В конце возвращаем **result**.
     
**Оценка:**
     По времени мы потратим **O**(**1**), так как цикл **for** идет по хэш-таблице, размер которой постоянен и не зависит от **N**. Память тоже будет **O**(**1**), так как хэш-таблица не зависит от **N** и будет всегда одинаковой. Еще есть такой интересный момент, что реализация жадного выбора до тех пор, пока мы можем его делать для конкретного ключа через цикл, работает во много раз быстрее, чем реализация через целочисленное деление и деление по модулю. По идее, должно быть наоборот, так как эти два деления процессор выполняет без особых затрат, а вот циклическое повторение одних и тех же строк кода ест много производительности. Скорее всего это какой-то прикол интерпретатора **Python**, так как на компилируемых языках (С/**C**++) реализация без лишнего цикла намного быстрее. В общем и целом, мой совет следующий, при реализации учитывайте особенности своего языка, потому что, например, как тут они могут быть далеко не такими очевидными, как кажутся.
