<div align='center'>
<h1><a href='https://leetcode.com/problems/trapping-rain-water/description/'><strong>16) Trapping Rain Water</strong></a></h1>
</div>

## **Условие:**

Дан массив из **n** положительных чисел, которые представляют карту высот, где ширина каждого столбика равна **1**. Нужно посчитать сколько воды можно поймать после дождя. (смотри картинку)

## **Идея:**

Вся сложность состоит в том, чтобы вывести формулу для вычисления объема воды в ямке.

## **Реализация:**

Сначала я приведу не очень оптимальное решение, но его последующая оптимизация даст нам искомое решение.

Я буду искать ямки. Под ямкой я понимаю - кортеж (**i**, **j**), такой что **i** < **j**, также выполняется неравенства **height**[**i**] >= **height**[**k**] и **height**[**j**] >= **height**[**k**], для каждого **k**, удовлетворяющему неравенству **i** < **k** < **j**.

Для начала создадим указатель **start** = **0**, который в начале указывает на начло массива. Также создадим множество **result**, в которое мы будем заносить пары (**i**, **j**), где **i** - индекс столбика начала ямы, **j** - индекс столбика окончания ямы, при этом **i** < **j**.

Теперь с помощью цикла **for** **i** **in** **range**(**1**, **len**(**height**)), я буду искать подходящие нам ямки. Условие при котором ямка нам подходит: **height**[**i**] >= **height**[**start**], если мы нашли такую ямку, то мы добавляем её в множество и двигаем указатель **start** на **i** позицию.

Таким образом на этот цикл мы найдем все ямки (**i**, **j**) с начала массива.

Теперь сделаем то же самое, только начнем с конца массива. Мы будем искать те же самые ямки (**i**, **j**). Для этого создадим еще один указатель **end** = **len**(**height**) - **1**. (можно воспользоваться **start**, но для читаемости я не пожадничал и создал еще один указатель). Если **height**[**i**] >= **height**[**end**], то мы нашли ямку, в которой можно поймать воду, записываем её в множество и двигаем **end** на **i** позицию.

После того как мы прошли эти два цикла, мы нашли все возможные ямки, в которых по условию можно поймать какое-то количество воды. (Предлагаю самостоятельно доказать, что два вот таких прохода и два условия **height**[**i**] >= **height**[**start**] и **height**[**i**] >= **height**[**end**] позволяют нам найти все ямки (**i**, **j**))

Ответом будет суммарное количество воды, которое можно поймать в каждой ямке. Чтобы посчитать его пройдемся по всем парам нашего множества. Как будет вычисляться количество воды в ямке? Сначала найдем самый высокий уровень воды, при котором она "не вытекает" из ямки. Это будет минимум из **height**[**i**] и **height**[**j**], потому, что если уровень воды будет выше этого минимума, то эта вода "выльется" из ямки, а нам нужно её поймать. Теперь нам нужно пройти по всем **k**-тым столбикам, находящимся, между **i** и **j** (**i** < **k** < **j**)(**i** и **j** не включаем, так как это границы ямки). Количество воды в этом столбике будет равно минимальной границе минус высота данного столбика. Просуммировав количество воды в столбиках (это интеграл кстати), получим количество воды в ямки.

**water** += **min_height** - **height**[**i**]

Повторяя эту процедуру для каждой ямки, получим суммарное пойманное количество воды в ямках.



После того как задача стала очевидной и простой, можно заняться оптимизированием решения. Например, очевидно, что можно обойтись без множества и последнего цикла для подсчета суммарного количества воды. (Очевидно это, потому что суммарное количество воды в ямках равно сумме количеств воды в ямках, из этой суммы следует линейная независимость нашего алгоритма (Результат сумма, а слагаемые не пересекаются, то есть независимы), а два наших цикла линейны, поэтому мы можем независимо посчитать эти суммы в них) Это можно делать динамически в тех двух циклах, где мы находим ямки (**i**, **j**). Теперь когда мы найдем ямку, то мы добавим в **result** (теперь это просто число), значение воды в этой ямке, которое мы динамически посчитаем.

Рассмотрим первый цикл, а второй будет аналогичным. Создадим вспомогательную переменную **tmp**, в которой будем считать воду в гипотетической ямке, когда наша ямка станет реальной (выполнится необходимое неравенство), ты мы добавим **tmp** в **result**. Для расчета **tmp** нам понадобится минимальная высота **small** в этой ямке, она будет равна **height**[**start**], так как реальная ямка, найденная в нашем цикле должна удовлетворять условию: **height**[**i**] >= **height**[**start**], то очевидно, что **small** = **height**[**start**].

Теперь по формуле выведенной в первом решении, получим что **tmp** += **small** - **height**[**i**], только нужно учесть, что мы добавляем эту разность в **tmp**, только если она >=**0**, иначе мы просто добавляем **0**.

Когда мы найдем подходящую нам ямку, мы просто добавляем в **result** += **tmp**, двигаем указатель **start** на **i** позицию и не забываем обнулить **tmp**.

Для второго цикла аналогично, только стоит не забыть про две вещи: **1**) обязательно обнулить **tmp** после первого цикла(либо создать новую временную переменную, проинициализировав её **0**), **2**) условие ямки должно быть **height**[**i**] > **height**[**end**], так как мы отказались от множества, то мы теперь можем столкнуться с пересчетом уже посчитанных ямок, чтобы этого избежать мы делаем это неравенство строгим.



## **Оценка:**

Первый алгоритм затратит **O**(**N**) времени. По памяти оценить его сложно так как мы сохраняем пары (**i**, **j**), но в теории в наихудшим случае у нас будет **N** * (**N** - **1**) / **2** пар, сохранено в множестве, что говорит об затратах по памяти **O**(**N**^**2**), но вероятность наихудшего исхода при **N** стремящимся к бесконечности стремится к **0**, поэтому в среднем будет затрачено **O**(**1**) памяти. Второе решение затратит **O**(**N**) времени, при этом константа будет намного меньше, следовательно алгоритм будет быстрее(скорость увеличится примерно в **1**.**5** раза). В этом случае память уже точно будет **O**(**1**).

## Код:
```python
from typing import List


class Solution:
    def trap(self, height: List[int]) -> int:
        start = 0
        result = set()
        for i in range(1, len(height)):
            if height[i] >= height[start]:
                result.add((start, i))
                start = i
        end = len(height) - 1
        for i in range(len(height) - 2, -1, -1):
            if height[i] >= height[end]:
                result.add((i, end))
                end = i
        water = 0
        for pair in result:
            min_height = min(height[pair[0]], height[pair[1]])
            for i in range(pair[0] + 1, pair[1]):
                water += min_height - height[i]
        return water

    def trap2(self, height: List[int]) -> int:
        start = 0
        result = 0
        tmp = 0
        for i in range(1, len(height)):
            small = height[start]
            tmp += (small - height[i]) if (small - height[i]) > 0 else 0
            if height[i] >= height[start]:
                result += tmp
                start = i
                tmp = 0
        end = len(height) - 1
        tmp = 0
        for i in range(len(height) - 2, -1, -1):
            small = height[end]
            tmp += (small - height[i]) if (small - height[i]) > 0 else 0
            if height[i] > height[end]:
                result += tmp
                end = i
                tmp = 0
        return result


if __name__ == "__main__":
    s = Solution()
    print(s.trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))  # 6
    print(s.trap([4, 2, 0, 3, 2, 5]))  # 9

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/15.Candy'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/17.Roman%20to%20Integer'>следующая задача ➡️</a></h3></div>