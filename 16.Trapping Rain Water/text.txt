16) Trapping Rain Water
https://leetcode.com/problems/trapping-rain-water/description/
Условие:
Дан массив из n положительных чисел, которые представляют карту высот, где ширина каждого столбика равна 1. Нужно посчитать сколько воды можно поймать после дождя. (смотри картинку)
Идея:
Вся сложность состоит в том, чтобы вывести формулу для вычисления объема воды в ямке.
Реализация:
     Сначала я приведу не очень оптимальное решение, но его последующая оптимизация даст нам искомое решение.
     Я буду искать ямки. Под ямкой я понимаю - кортеж (i, j), такой что i < j, также выполняется неравенства height[i] >= height[k] и height[j] >= height[k], для каждого k, удовлетворяющему неравенству i < k < j.
     Для начала создадим указатель start = 0, который в начале указывает на начло массива. Также создадим множество result, в которое мы будем заносить пары (i, j), где i - индекс столбика начала ямы, j - индекс столбика окончания ямы, при этом i < j.
     Теперь с помощью цикла for i in range(1, len(height)), я буду искать подходящие нам ямки. Условие при котором ямка нам подходит: height[i] >= height[start], если мы нашли такую ямку, то мы добавляем её в множество и двигаем указатель start на i позицию.
     Таким образом на этот цикл мы найдем все ямки (i, j) с начала массива.
     Теперь сделаем то же самое, только начнем с конца массива. Мы будем искать те же самые ямки (i, j). Для этого создадим еще один указатель end = len(height) - 1. (можно воспользоваться start, но для читаемости я не пожадничал и создал еще один указатель). Если height[i] >= height[end], то мы нашли ямку, в которой можно поймать воду, записываем её в множество и двигаем end на i позицию.
     После того как мы прошли эти два цикла, мы нашли все возможные ямки, в которых по условию можно поймать какое-то количество воды. (Предлагаю самостоятельно доказать, что два вот таких прохода и два условия height[i] >= height[start] и height[i] >= height[end] позволяют нам найти все ямки (i, j))
     Ответом будет суммарное количество воды, которое можно поймать в каждой ямке. Чтобы посчитать его пройдемся по всем парам нашего множества. Как будет вычисляться количество воды в ямке? Сначала найдем самый высокий уровень воды, при котором она "не вытекает" из ямки. Это будет минимум из height[i] и height[j], потому, что если уровень воды будет выше этого минимума, то эта вода "выльется" из ямки, а нам нужно её поймать. Теперь нам нужно пройти по всем k-тым столбикам, находящимся, между i и j (i < k < j)(i и j не включаем, так как это границы ямки). Количество воды в этом столбике будет равно минимальной границе минус высота данного столбика. Просуммировав количество воды в столбиках (это интеграл кстати), получим количество воды в ямки.
     water += min_height - height[i]
     Повторяя эту процедуру для каждой ямки, получим суммарное пойманное количество воды в ямках.

     После того как задача стала очевидной и простой, можно заняться оптимизированием решения. Например, очевидно, что можно обойтись без множества и последнего цикла для подсчета суммарного количества воды. (Очевидно это, потому что суммарное количество воды в ямках равно сумме количеств воды в ямках, из этой суммы следует линейная независимость нашего алгоритма (Результат сумма, а слагаемые не пересекаются, то есть независимы), а два наших цикла линейны, поэтому мы можем независимо посчитать эти суммы в них) Это можно делать динамически в тех двух циклах, где мы находим ямки (i, j). Теперь когда мы найдем ямку, то мы добавим в result (теперь это просто число), значение воды в этой ямке, которое мы динамически посчитаем.
     Рассмотрим первый цикл, а второй будет аналогичным. Создадим вспомогательную переменную tmp, в которой будем считать воду в гипотетической ямке, когда наша ямка станет реальной (выполнится необходимое неравенство), ты мы добавим tmp в result. Для расчета tmp нам понадобится минимальная высота small в этой ямке, она будет равна height[start], так как реальная ямка, найденная в нашем цикле должна удовлетворять условию: height[i] >= height[start], то очевидно, что small = height[start].
     Теперь по формуле выведенной в первом решении, получим что tmp += small - height[i], только нужно учесть, что мы добавляем эту разность в tmp, только если она >=0, иначе мы просто добавляем 0.
     Когда мы найдем подходящую нам ямку, мы просто добавляем в result += tmp, двигаем указатель start на i позицию и не забываем обнулить tmp.
     Для второго цикла аналогично, только стоит не забыть про две вещи: 1) обязательно обнулить tmp после первого цикла(либо создать новую временную переменную, проинициализировав её 0), 2) условие ямки должно быть height[i] > height[end], так как мы отказались от множества, то мы теперь можем столкнуться с пересчетом уже посчитанных ямок, чтобы этого избежать мы делаем это неравенство строгим.
     
Оценка:
     Первый алгоритм затратит O(N) времени. По памяти оценить его сложно так как мы сохраняем пары (i, j), но в теории в наихудшим случае у нас будет N * (N - 1) / 2 пар, сохранено в множестве, что говорит об затратах по памяти O(N^2), но вероятность наихудшего исхода при N стремящимся к бесконечности стремится к 0, поэтому в среднем будет затрачено O(1) памяти. Второе решение затратит O(N) времени, при этом константа будет намного меньше, следовательно алгоритм будет быстрее(скорость увеличится примерно в 1.5 раза). В этом случае память уже точно будет O(1).