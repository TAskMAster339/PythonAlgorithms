<div align='center'>
<h1><a href='https://leetcode.com/problems/sqrtx/description/'><strong>134) Sqrt(x)</strong></a></h1>
</div>

## **Условие:**

Дано неотрицательное число **x**, необходимо вернуть квадратный корень из **x**, округленный вниз. Сделать это нужно без встроенных функций вычисления степеней

## **Идея:**

Подобрать нужное число

## **Реализация:**

Будем перебирать все числа от **1** до **x** // **2** (можно до **x**, но корень будет меньше чем половина **x** для всех **x** > **2**).

Заметим, что натуральные числа представляют собой отсортированную по возрастанию последовательность. Зная это, мы можем быстро с помощью бинарного поиска найти необходимое корень.

Но еще я нашел более интересное решение, если представить числа в двоичном виде. Воспользуемся первой идеей для перебора чисел от **1** до **x** // **2**, в бинарных числах это значит переключать биты от **len**(**bin**(**x**)) // **2** до **0**.

Для этого вычислим количество бит в **x**. Создадим переменную **result** = **0**. С помощью количества бит в числе **x** создадим цикл от (**len**(**bin**(**x**)) + **1**) // **2** до -**1** с шагом -**1** будем переключать **i**-тый бит в **result** (Будем делать **i**-тый нулевой бит равным **1**). Теперь остается вспомнить про **backtrack**. Если полученное число в **result** в квадрате будет больше **x**, то необходимо совершить откат **i**-того бита.

Таким образом переключая биты с **0** на **1** в **result**, мы получим максимально возможное положительное целое число, квадрат которого максимально близок к **x**, но строго меньше **x**. А это нам и надо было найти.



## **Оценка:**

Сложность по времени бинарного поиска будет **O**(**log**(**X**)), **X** - данное нам число. Сложность по памяти будет **O**(**1**).

Сложность по времени бинарного решения будет **O**(**1**), так как у нас всего два цикла, длинна которых в наихудшем случае будет **64** (максимальная длина **int** = **64** бита), что константно. Сложность по памяти будет **O**(**1**).

## Код:
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x
        start, end = 1, x // 2
        while start <= end:
            mid = (start + end) // 2
            if x // mid == mid:
                return mid
            if x // mid < mid:
                end = mid - 1
            else:
                start = mid + 1
        return (start + end) // 2

    def mySqrt_bin(self, x: int) -> int:
        if x < 2:
            return x
        count = 0
        temp = x
        while temp:
            count += 1
            temp >>= 1
        result = 0
        for i in range((count + 1) // 2, -1, -1):
            result |= 1 << i
            if x // result < result:
                result ^= 1 << i
        return result


if __name__ == "__main__":
    f = Solution().mySqrt
    print(f(4))  # 2
    print(f(8))  # 2
    print(f(9))  # 3
    print(f(0))  # 0

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/133.Factorial%20Trailing%20Zeroes'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>