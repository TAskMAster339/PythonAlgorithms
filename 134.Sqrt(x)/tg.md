**134) Sqrt(x)**
https://leetcode.com/problems/sqrtx/description/
**Условие:**
Дано неотрицательное число **x**, необходимо вернуть квадратный корень из **x**, округленный вниз. Сделать это нужно без встроенных функций вычисления степеней
**Идея:**
Подобрать нужное число
**Реализация:**
    Будем перебирать все числа от **1** до **x** // **2** (можно до **x**, но корень будет меньше чем половина **x** для всех **x** > **2**).
    Заметим, что натуральные числа представляют собой отсортированную по возрастанию последовательность. Зная это, мы можем быстро с помощью бинарного поиска найти необходимое корень.
    Но еще я нашел более интересное решение, если представить числа в двоичном виде. Воспользуемся первой идеей для перебора чисел от **1** до **x** // **2**, в бинарных числах это значит переключать биты от **len**(**bin**(**x**)) // **2** до **0**.
    Для этого вычислим количество бит в **x**. Создадим переменную **result** = **0**. С помощью количества бит в числе **x** создадим цикл от (**len**(**bin**(**x**)) + **1**) // **2** до -**1** с шагом -**1** будем переключать **i**-тый бит в **result** (Будем делать **i**-тый нулевой бит равным **1**). Теперь остается вспомнить про **backtrack**. Если полученное число в **result** в квадрате будет больше **x**, то необходимо совершить откат **i**-того бита.
    Таким образом переключая биты с **0** на **1** в **result**, мы получим максимально возможное положительное целое число, квадрат которого максимально близок к **x**, но строго меньше **x**. А это нам и надо было найти.

**Оценка:**
    Сложность по времени бинарного поиска будет **O**(**log**(**X**)), **X** - данное нам число. Сложность по памяти будет **O**(**1**).
    Сложность по времени бинарного решения будет **O**(**1**), так как у нас всего два цикла, длинна которых в наихудшем случае будет **64** (максимальная длина **int** = **64** бита), что константно. Сложность по памяти будет **O**(**1**).
