<div align='center'>
<h1><a href='https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/'><strong>4) Remove Duplicates from Sorted Array II</strong></a></h1>
</div>

Идея: нужно использовать два указателя. Только сложность заключается в логике их изменения

Сначала создадим переменную **count**, которая будет считать сколько раз подряд встретились нам одинаковые числа. Указатель **w** (**write**) будет указывать туда, куда  будет происходит запись элемента. Также нам понадобится **flag**.

Решение таково: идем по списку циклом **for** с переменной **i**, выступающей вторым указателем. Сравниваем подряд идущие пары. Если они равны, то делаем **count** += **1**, иначе **count** = **1**.(не **0**, так как в паре есть **1** число) Затем нам важно заметить момент, когда **count** "впервые" превысит **2**, только для этого и нужен наш флаг. В этот момент мы присвоем значение нашему итератору **w** = **i** + **1**, а флагу присвоим значение **false**, ибо нам больше не нужно выполнять этот блок кода.

Далее, если **w** != **0** и **count** <= **2**, то мы записываем по индексу **w** значение по индексу **i** + **1**. Не забываем иннкрементировать **w**. Это довольно сложный для понимания момент, но я думаю, что это проще понять вот так.

Когда мы впервые находим тройку чисел, то мы понимаем две вещи:

**1**) Нам необходимо перезаписать элементы по всем индексам в диапазоне [**w**, **len**(**nums**) )

**2**) Начало(индекс **w**) - место третьего элемента в тройки одинаковых элементов.

Затем мы находим уникальный элемент (не равный элементам предыдущей тройки), после этого мы записываем его по ранее найденому индексу **w**. Такую операцию мы можем сделать, только для двух уникальных элементов, благодаря условию **count** <= **2**. Повторяю данную операцию до конца цикла, мы расставим оставшиеся элементы в том порядке, в которм от нас требует задача.

В конце нам нужно вернуть **w**, если оно оказалось равно **0**, это значит, что список не был изменен, так как он изначально удовлетворял условию задачи, тогда возвращаем **len**(**nums**).

**1** цикл **for** по длине массива, следовательно сложность алгоритма **O**(**n**).



Дополнительно.

Следующие решение я нашел на литКоде, оно более простое, но как до такого додуматься я вообще не понимаю.

Во-первых, можно доказать, что массив из **2** и менее элементов всегда удовлетворяет условию нашей задачи. Поэтмоу если **len**(**nums**) <= **2**, мы просто возвращаем длину. Если это не так, что мы создаем указатель **slow**, который будет практически аналогичен моему **w**. И пробегаем по списку циклом **for**, переменной которого выступает **fast**.

Во-вторых, нужно заметить, что сравнивая **nums**[**fast**] != **nums**[**slow** - **2**], мы можем найти момент, когда нужно двигать **slow**, и перезаписывать значения по нему.

Логика здесь следующая:

Если **nums**[**fast**] == **nums**[**slow** - **2**], то мы понимаем, что у нас подряд идут **3** и более одинаковых элементов, **slow** как раз будет указывать на **3**, который будет перезаписан как только **nums**[**fast**] станет не равным **nums**[**slow** - **2**], это значит, что мы нашли уникальный элемент, не равный одинаковым, поэтому мы его сразу записываем в **nums**[**slow**], не забывая после этого инкрементировать **slow**.

В конце мы просто возращаем **slow**.

## Код:
```python
from typing import List


class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 1
        w = 0
        flag = True
        for i in range(len(nums) - 1):
            if nums[i] == nums[i + 1]:
                count += 1
            else:
                count = 1
            if count > 2 and flag:
                w = i + 1
                flag = False
            if w != 0 and count <= 2:
                nums[w] = nums[i + 1]
                w += 1
        if w == 0:
            return len(nums)
        return w

    def removeDuplicates2(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)

        slow = 2

        for fast in range(2, len(nums)):
            if nums[fast] != nums[slow - 2]:
                nums[slow] = nums[fast]
                slow += 1

        return slow


if __name__ == "__main__":
    s = Solution()
    print(s.removeDuplicates([1, 1, 1, 2, 2, 3]))
    print(s.removeDuplicates([0, 0, 1, 1, 1, 1, 2, 3, 3]))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/3.Remove%20Duplicates%20from%20Sorted%20Array'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/5.Majority%20Element'>следующая задача ➡️</a></h3></div>