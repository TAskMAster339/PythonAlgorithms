# [**10) Jump Game II**](https://leetcode.com/problems/jump-game-ii/description/)

Идея: очевидно, что нужно как-то динамически рассчитывать самый дальний прыжок из клетки, где мы стоим.

Для этого создадим три ключевые переменные - **near**, **far**, **jumps**, **near** - индекс ближайшего прыжка, **far** - индекс самого выгодного прыжка. (Самый выгодный прыжок тот, после которого мы либо дойдем до конца, либо сможем сделать еще один самый выгодный прыжок). Ну а **jumps** будет общим счетчиком наших прыжков, его мы вернем в конце процедуры.

Создадим два цикла, первый будет итерироваться до тех пор, пока индекс самого выгодного прыжка меньше, чем длина входного массива минус один. Второй цикл нужен для вычисления следующего индекса самого выгодного прыжка. Затем мы просто обновляем наши переменные: **near** становиться следующим за **far** индексом, **far** становиться индексом самого выгодного прыжка, **jumps** инкрементируется.

В итоге мы получим один вложенный цикл, но это не особая проблема, так как он всегда будет много меньше по сравнению с **N**, и поскольку в нем вообще не фигурирует **N**, то его можно считать за константу, правда эта константа очень большая. Поэтому эффективность данного алгоритма **O**(**N**).

Однако, поискав я нашел, как развернуть этот цикл. Теперь мы создаем переменные для подсчета прыжков, индекса конца (Туда куда мы можем максимум допрыгнуть) и переменную, хранящую наш самый длинный прыжок. Идея следующая, мы идем по массиву, узнаем на сколько мы можем прыгнуть, и вычисляем самый длинный прыжок. Индекс конца будет равен нашему индексу плюс наш самый длинный прыжок. Теперь нам остается повторять этот алгоритм, либо до конца цикла, либо до того как наш конец превысит длину массива.

Для лучшего понимания этот алгоритм можно интерпретировать вот так. У нас есть две задачи. **1**) Идти по массиву с **0** до конца. **2**) Искать самый длинный прыжок из прыжков, которые мы встретим на пути. В начале наш самый длинный прыжок, тот с которого мы начали. Например, он равен **3**. Далее мы идем на три клетки вперед, параллельно смотря ну содержащиеся в этих клетках прыжки, таким образом мы находим наибольший прыжок в этом промежутке. После того как мы дошли до **3** клетки. Мы увеличиваем счетчик количества прыжков на один, затем продолжаем наш алгоритм аналогичным образом, только теперь в начале нашим самым длинным прыжком будет максимум из значения клетки, на которой мы остановились, и найденного ранее самого длинного прыжка.

Таким образом, за один проход, мы гарантировано посчитаем минимальное количество прыжков, которое нужно, чтобы добраться с начала до конца массива. Эффективность **O**(**N**), но тут уже константа менее значима, это хорошо заметно при маленьких тестах. При больших тестах время решений будет отличаться только в пределах погрешности.

## Код:
```python
from typing import List


class Solution:
    def jump(self, nums: List[int]) -> int:
        near = far = jumps = 0

        while far < len(nums) - 1:
            farthest = 0
            for i in range(near, far + 1):
                farthest = max(farthest, i + nums[i])

            near = far + 1
            far = farthest
            jumps += 1

        return jumps

    def jump2(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0  # Already at the last index

        jumps = 0
        current_end = 0
        farthest = 0

        for i in range(n - 1):  # No need to check the last element
            # Update the farthest point reachable from here
            jump = i + nums[i]
            if farthest < jump:
                farthest = jump

            # If we have reached the end of the current jump's range
            if i == current_end:
                jumps += 1
                current_end = farthest

                # If the current_end reaches or goes beyond the last index
                if current_end > n - 1:
                    break

        return jumps


if __name__ == "__main__":
    s = Solution()
    print(s.jump2([2, 3, 1, 1, 4]))
    print(s.jump2([2, 3, 0, 1, 4]))
    print(s.jump([1, 2]))
    print(s.jump([1, 2, 3]))
    print(s.jump([0]))
    print(s.jump([1, 2, 1, 1, 1]))  # 3

```

