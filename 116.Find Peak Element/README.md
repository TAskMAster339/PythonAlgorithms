<div align='center'>
<h1><a href='https://leetcode.com/problems/find-peak-element/description/'><strong>116) Find Peak Element</strong></a></h1>
</div>

## **Условие:**

Дан массив целых чисел **nums**, в котором любые два рядом стоящих элемента не равны. Нужно вернуть индекс пикового элемента. Если в массиве несколько пиковых элементов, то можно вернуть любой из пиков.

Пиковый элемент - такой элемент, который строго больше своих соседей. (Если элемент находится на краю массива, то он должен быть строго больше одного своего соседа).

Необходимо реализовать алгоритм с скоростью **O**(**logN**)

## **Идея:**

Воспользоваться бинарным поиском

## **Реализация:**

Наш массив не отсортирован, но мы всё равно можем воспользоваться бинарным поиском. Наш массив можно представить в виде горного хребта, а нашу задачу найти какую-либо вершину горы. Так как любые два рядом стоящих элемента не равны, то мы можем сделать вывод, что как минимум один пик всегда будет в массиве.

Тогда появляется вопрос: как его найти? Или же более быстрый вопрос: как нам быстрее всего на него подняться?

Для этого будем подниматься как бинарный поиск. Сначала попробуем элемент по середине. Если он является пиком, тогда мы возвращаем его индекс. Если он не пик, то мы решаем куда нам дальше подниматься. Мы будем подниматься влево, если слева расположенный элемент больше серединного. Если правый элемент больше серединного, то мы будем подниматься вправо.

Повторяем эти действия, пока не достигнем пика. По сути мы ищем точно также как и в линейном поиске, но делая предположения, что пик всегда по середине, мы очень сильно оптимизируем поиск.

Увидеть разницу можно на картинке.



## **Оценка:**

Так как мы используем бинарный поиск, то мы получим верхнюю границу по времени **O**(**logN**).

Верхняя граница по памяти будет **O**(**1**).

## Код:
```python
class Solution:
    def findPeakElement(self, nums: list[int]) -> int:
        if len(nums) == 1:
            return 0

        start, end = 0, len(nums) - 1

        while start <= end:
            mid = (start + end) // 2
            if (
                (mid == 0 and nums[mid + 1] < nums[mid])
                or (mid == len(nums) - 1 and nums[mid - 1] < nums[mid])
            ) or (nums[mid - 1] < nums[mid] and nums[mid + 1] < nums[mid]):
                return mid
            if nums[mid + 1] > nums[mid]:
                start = mid + 1
            elif nums[mid - 1] > nums[mid]:
                end = mid - 1
        return start


if __name__ == "__main__":
    f = Solution().findPeakElement
    print(f([1, 2, 3, 1]))  # 2
    print(f([1, 2, 1, 3, 5, 6, 4]))  # 5

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/115.Search%20a%202D%20Matrix'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>