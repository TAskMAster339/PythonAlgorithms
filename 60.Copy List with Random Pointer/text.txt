60) Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/description/
Условие:
Дан связный список длинной n, каждый узел содержит указатель на какой-то случайный узел в списке. Нужно сделать глубокую копию списка. (В новом списке не должно быть ничего, что могло бы ссылаться на предыдущий).
Идея:
Надо постепенно копировать объекты.
Реализация:
     Я нашел следующие решение. Его легко понять, но сложно реализовать.
     Во-первых, сделаем копии каждому узлу в данном списке и расположим их пряма за оригиналом. (1->2->3  ==>  1->1->2->2->3->3)
     Во-вторых, пройдемся теперь по созданным нами копиям, они будут по четным индексам списка. Наша задача скопировать рандомные указатели. Логика следующая. Для i-того узла находим рандомный указатель i-1 узла. И двигаем этот указатель на следующий элемент (Следующий за ним будет его копией, которую мы создали раньше). Присваиваем i-тому узлу этот указатель в поле random.
     В-третьих, нужно разделить список. Сейчас у нас один большой список, где по нечетным индексам расположены элементы изначального списка, а по четным созданные нами глубокие копии соответствующих элементов. Этого достаточно, чтобы разделить список на два, на изначальный и на его копию. После разделения остается вернуть указатель на начало копии списка.

Оценка:
    Всего у нас будет три цикла, первый по времени займет O(N), второй O(2N), третий O(2N), где N - длина списка. Итого верхняя граница по времени равна O(N). По памяти мы затратим O(N) (потому что копируем).