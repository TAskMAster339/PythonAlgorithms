# [**9) Jump Game**](https://leetcode.com/problems/jump-game/description/)

Идея: заметим, что единственный случай, когда мы не можем дойти от начала до конца, это когда мы упираемся в непроходимый **0**.

Если список состоит из одного элемента, то мы возвращаем **True**. Создадим переменную **target**, с помощью которой будем проверять найденный нуль на проходимость, еще нам понадобится логическая переменная **zero_flag**, равная **True**, если нуль не проходим, иначе **False**.

Далее мы идем по списку, начиная с предпоследнего элемента, заканчивая первым. Если **nums**[**i**] оказался равным **0** и это первый встретившийся нам **0**, то мы поднимаем **zero_flag** и присваиваем **target** = **2**, так как чтобы пройти через этот нуль, нам нужно найти такое **nums**[**i**] >= **2**.

Теперь, когда мы нашли нуль, мы проверяем можно ли через него пройти, если можно, то устанавливаем **target** = **0** и опускаем флаг нуля, если нельзя, то увеличиваем **target** на **1**, так как следующие число будет на **1** дальше от этого нуля. Также тут мы наивно предполагаем, что рано или поздно может найтись такой элемент, который перешагнет этот нуль.

После цикла возвращаем **target** == **0**. Это выражение истинно, если в нашем массиве нет нулей, или все нули в нашем массиве проходимы. Если **target** != **0**, то есть такой нуль, который пройти не возможно, следовательно дойти от начала списка до конца не представляется возможным.

Сложность алгоритма **O**(**n**) по времени и **O**(**1**) по памяти.

