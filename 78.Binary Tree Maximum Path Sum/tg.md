**78) Binary Tree Maximum Path Sum**
https://leetcode.com/problems/binary-tree-maximum-path-sum/description/
**Условие:**
Под путем в бинарном дереве понимается последовательность узлов, в котором пара смежных узлов в последовательности соединена ребром. Узел может появится в последовательности не больше **1** раза. Путь не обязан проходить через корень **root**.
Сумма пути это сумма всех значений **val** узлов в пути.
Дан корень **root** бинарного дерева, нужно вернуть максимальную сумму непустого пути.
**Идея:**
Нам нужно считать, а не найти этот путь, поэтому задача упрощается.
**Реализация:**
    Алгоритм будет в следующем:
    Реализуем обратный поиск в глубину. 
    Крайний случай это когда узел равен **None**, тогда мы возвращаем **0**.
    Рекуррентный случай - считаем максимальную сумму пути в левом и правом поддеревьях узла. (Берем максимум от **высcчитаного** значения и **0**, чтобы учесть отрицательные узлы). Возвращаем максимум из высчитанных сумм плюс значение **val** самого узла
    Такой обход посчитает нам максимальную сумму пути от корня до листа, НО не факт, что он будет наибольшем в дереве. Мы не рассмотрим множество других путей, не проходящих через корень **root**. Для того, чтобы найти наибольший путь в дереве, модернизируем алгоритм.
    Создадим переменную **path_sum**, в которой будем считать наш максимальный путь, её в конце и вернем. После того, как мы рассчитали сумму пути левого и правого поддерева узла, мы будем обновлять значение **path_sum** = **max**(**path_sum**, **left_sum** + **right_sum** + **node**.**val**). Сумма в скобках, представляет собой объединение самого большого пути в левом поддереве с самым большим путем правого поддерева. (Это будет самый большой путь, содержащий узел **node**)
    Таким образом запустив наш алгоритм от корня, мы рассмотрим все узлы, а следовательно все самые большие пути в поддеревьях и вернем максимально возможный путь

**Оценка:**
    По времени классический **dfs** затратит **O**(**N**), где **N** - количество узлов в дереве. По памяти те же самые **O**(**N**), где **N** - размер стека рекурсии.
