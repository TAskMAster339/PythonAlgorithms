**88) Validate Binary Search Tree**
https://leetcode.com/problems/validate-binary-search-tree/description/
**Условие:**
Дан корень **root** бинарного дерева, нужно определить является ли оно бинарным деревом поиска **BST**
Бинарное дерево поиска обладает следующими свойствами:
**1**. Левое поддерево содержит только узлы со значениями меньшими, чем значение корня.
**2**. Правое поддерево содержит только узлы со значениями большими, чем значение корня
**3**. И левое и правое поддеревья являются тоже бинарными деревьями поиска.
**Идея:**
Можно написать крутой **DFS** с верхней и нижней границами, но я просто пойду по **LNR**
**Реализация:**
    Мы будем идти по дереву с помощью центрированного обхода **DFS** **LNR**. При таком обходе только **BST** даст нам возрастающую последовательность чисел. Чтобы проверить её, будем запоминать предыдущие число и сравнивать его с текущим. Если текущие оказалось меньше или равно предыдущему, то возвращаем **False**. (Удобно создать флаг (из-за не очень хорошо работающего **return** в рекурсии), который будем поднимать и затем же с помощью него оптимизировать лишние рекурсии)

**Оценка:**
    Классическая оценка **DFS** по времени **O**(**N**), по памяти **O**(**N**), где **N** - количество узлов в дереве.
