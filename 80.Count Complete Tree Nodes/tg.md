**80) Count Complete Tree Nodes**
https://leetcode.com/problems/count-complete-tree-nodes/description/
**Условие:**
Дан корень **root** заполненного бинарного дерева. Нужно вернуть количество узлов в дереве. Алгоритм должен быть быстрее, чем **O**(**N**).
Заполненное бинарное дерево - бинарное дерево, в котором на каждый уровень, кроме последнего, полностью заполнен, при этом узлы в последнем уровне располагаются слева настолько, насколько это возможно
**Идея:**
Нужно загуглить про идеальное бинарное дерево
**Реализация:**
    Идеальное бинарное дерево - бинарное дерево, в котором есть все узлы имеют детей, кроме листьев, при этом все листья расположены на одном и том же уровне. Идеальное бинарное дерево всегда является заполненным, обратное не верно.
    Если мы сможем доказать, что наше заполненное дерево - идеальное, то мы сможем посчитать количество его узлов по формуле **2**^**h** - **1**, где **h** - глубина дерева.
    Для того, чтобы доказать, что наше заполненное дерево - идеальное, нужно проверить глубину до самого левого листа и глубину до самого правого листа.
    Если они равны, то по определению заполненного дерева, мы делаем вывод, что самый последний уровень полный, следовательно, дерево - идеальное и количество узлов в нем равно **2**^**h** - **1**.
    Иначе мы вызываем повторяем алгоритм рекурсивно для левого и правого поддеревьев. Возвращаем сумму их узлов + **1** (учитывая корень).

**Оценка:**
    Верхняя оценка по времени будет **O**(**log**^**2** **N**) (**O** (**logN** * **logN**)), так как расчет глубины в наихудшем случае будет **O**(**logN**), также в наихудшем случае нам потребуется рассчитать **logN** раз эту глубину.(Также очень хорошая оптимизация - замена **2**^**h** - **1** на **1** << **h** - **1**, где << - битовый сдвиг влево) По памяти мы затратим **O**(**logN**), так как в наихудшем случае размер стека рекурсии будет **logN**.
