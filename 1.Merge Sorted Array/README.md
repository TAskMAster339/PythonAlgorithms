# [**1) Merge Sorted array**](https://leetcode.com/problems/merge-sorted-array/description/)
Идея: идем по списку 1 с конца, каждый раз записывая наибольший из элементов списков 1 и 2.
Идея состоит в том, чтобы итерироваться по первому списку из конца в начало. Для этого создадим итератор **i**, который будет равен равен последнему индексу первого списка (**m**+**n**-**1**). Затем каждую итерацию мы будем уменьшать его значение. В ячейку, расположенную по этому итератору мы будем записывать максимум из двух наибольших элементов списков. Так как списки у нас по условию отсортированы, то максимальный элемент у второго списка находиться по (**n**-**1**) индексу, а у первого списка по (**m**-**1**) индексу. Теперь пока есть элементы во втором списке, мы будем сравнивать пары, постоянно записывая наибольший элемент из пары в конец списка, после чего итератор списка, из которого мы записали максимум, будет уменьшаться на **1**, что позволит нам каждую итерацию сравнивать новые пары чисел. Очень важно условие **m** >= **0**, так как благодаря ему мы не выходим за границы списка и также решаем случаи, когда в первом списке уже закончились элементы, в то время как во втором еще остались.

Всего будет выполнено **m**+**n** итераций. Сложность алгоритма **O**(**m**+**n**)

## Код:
```python
from typing import List


class Solution:
    def merge(
        self, nums1: List[int], m: int, nums2: List[int], n: int
    ) -> None:
        m, n, i = m - 1, n - 1, m + n - 1
        while n >= 0:
            if m >= 0 and nums1[m] > nums2[n]:
                nums1[i] = nums1[m]
                m -= 1
            else:
                nums1[i] = nums2[n]
                n -= 1
            i -= 1


if __name__ == "__main__":
    s = Solution()
    s.merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3)
    s.merge([1], 1, [], 0)
    s.merge([0], 0, [1], 1)
    s.merge([1, 0], 1, [2], 1)

```

