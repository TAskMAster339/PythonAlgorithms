87) Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
Условие:
Дан корень root бинарного дерева поиска BST и число k, нужно вернуть k-ую порядковую статистику среди значений в дереве.
k-ая порядковая статистика - значение случайной величины, которое расположено на k-ом месте в отсортированной по возрастанию последовательности значений выборки случайной величины.
1-ая порядковая статистика - минимум
n-ая порядковая статистика - максимум
Идея:
Помните про центрированный обход DFS LNR?
Реализация:
    Создадим переменную в которую будем записывать k-ую порядковую статистику. При работе DFS будем для каждого узла уменьшать значение k на единицу. Когда k == 0, то значит мы нашли нашу статистику обновляем нашу переменную. Еще при этом хорошей оптимизацией будет сразу заканчивать поиск, если k < 0, мы так сэкономим кучу времени.

    Доп. момент:
    Если нужно часто вычислять k-ую порядковую статистику, то лучше будет оптимизировать класс узла дерева. Туда можно добавить переменную, в которой будет записана сумма количества узлов в левом и правом поддеревьях + 1.
    С помощью этого числа, можно, используя бинарный поиск, быстро находить k-ую порядковую статистику (сложность будет O(logN) по времени, O(1), по памяти).
    Например, если у нас есть корень со значением 15, в его левом поддереве количество узлов равно 10, то мы делаем вывод, что 15 - есть 11-ая порядковая статистика. Если k < 11, то аналогичную операцию делаем в левом поддереве, иначе в правом. Таким образом за logN действий мы найдем нашу статистику.

Оценка:
    Верхняя граница по времени у DFS LNR будет O(N), где N - количество узлов в дереве. По памяти на стек уйдет в наихудшем случае O(N).
