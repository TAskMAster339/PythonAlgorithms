**110) Construct Quad Tree**
https://leetcode.com/problems/construct-quad-tree/description/
**Условие:**
Дана матрица **grid** размером **n** **x** **n**, состоящая из **0** и **1**. Мы хотим превратить матрицу в **Quad**-**Tree**. Нужно вернуть построенное **Quad**-**Tree**.
**Quad**-**Tree** - структура данных, в которой каждый узел имеет ровно **4** наследника и **2** атрибута: **val** значение и **isLeaf** булева переменная, показывая является ли узел листом. Подробнее в **https**://**en**.**wikipedia**.**org**/**wiki**/**Quadtree**. Еще смотрите картинку
**Идея:**
Задачу очень легко можно разделить на подобную более простую задачу
**Реализация:**
    Классическая задача для презентации подхода "Разделяй и Властвуй".
    В процессе разделения мы будем делить задачу на **4** части, потому что **Quad**-**Tree** состоит из **4** поддеревьев, которые тоже являются **Quad**-**Tree**.
    Когда мы дойдем до **Quad**-**Tree** размером **1**, то мы будем заниматься властвованием, объединением малых поддеревьев в большие.
    Реализуется это через простую рекурсию:
    Крайний случай - когда размер нашей сетки **grid** равен **1** **x** **1**. Тогда мы возвращаем узел без детей с единственным значением, которое есть в **grid**, **isLeaf** ставим **True**, так как это самое маленькое поддерево, оно очевидно должно быть листом.
    Рекуррентный случай - **4** раза вызываем нашу функцию на уже на срезах массива, каждый из которых представляет собой либо, верхний левый квадрат матрицы, либо верхний правый квадрат матрицы, либо нижний левый квадрат матрицы, либо нижний правый квадрат матрицы.
    Если все из них имеют одинаковое значение и при этом все листы, то мы можем их объединить в один узел, который будет иметь значения одного из поддеревьев (не важно какого, они все будут равны), и тоже будет листом.
    Иначе мы возвращаем новый узел, который будет иметь значение **1**, **isLeaf** = **False**, и **4** ранее созданных наследника (поддерева).

**Оценка:**
    Верхняя оценка по памяти будет **O**(**N**^**2**), так как мы в наихудшем случае создадим узел для каждого числа в матрицы размером **N** **x** **N**. Хотя эту память можно признать полезной, тогда дополнительной памяти будет затрачено **O**(**logN**) на глубину рекурсии.
    Верхняя оценка по времени будет **O**(**N**^**2**), потому что в наихудшем случае алгоритм пройдет во всем числам матрицы, что будет стоить **O**(**N**^**2**). При этом мы не учитываем расходы на создание подматриц (копирование массивов). С ними получиться **O**(**N**^**2** * **log** **N**). Но это легко поправимо, если передавать ссылки на **view** матрицы, а не множить копии.
