<div align='center'>
<h1><a href='https://leetcode.com/problems/course-schedule-ii/description/'><strong>94) Course Schedule II</strong></a></h1>
</div>

## **Условие:**

Всего есть **numCourses** курсов, которые нужно пройти. Каждый курс имеет свой номер от **0** до **numCourses** - **1**. Дан массив **prerequisites**, где **prerequisites**[**i**] = [**a_i**, **b_i**], означает, что перед тем как пройти курс **b_i**, необходимо пройти **a_i**.

Нужно вернуть порядок курсов, который позволяет пройти все курсы. Если ответов несколько, вернуть можно любой. Если невозможно закончить все курсы, верните пустой массив

## **Идея:**

Нужно представить курсы в виде графа и топологически отсортировать его.

Топологическая сортировка - упорядочивание вершин ациклического ориентированного графа согласно частичному порядку, заданному рёбрами ориентированного графа на множестве его вершин.

## **Реализация:**

Для этого воспользуемся алгоритмом Кана. Если граф можно топологически отсортировать, то в нем существует такая вершина, в которую не входит ни одно ребро графа. Алгоритм Кана состоит в том, чтобы найти такую вершину и начать обходить граф в ширину, начиная с неё. Затем исключить эту вершину из графа и начать алгоритм снова над уже новым графом. В конце мы получим список вершин в порядке топологической сортировки нашего графа.

Для этого создадим массив **in_degree**, в котором на **i**-том индексе будет храниться количество ребер, входящих в **i**-тую вершину. Если по **i**-тому индексу лежит **0**, то это значит, что в эту вершину не входят ребра. Добавляем её в очередь и начинаем **BFS**.

Достаем вершину из очереди, добавляем её в **result** и проходим по связными с нею вершинами. Как бы уберем эту вершину из графа, для этого из **in_degree**[**child**] вычтем **1** (Так как вершина пропала, пропало и ребро, входящие в связную с ней вершину). Если значение входящих ребер стало равным **0**, то добавляем вершину в очередь.

В конце возвращаем **result**, если его длина равна **numCourses**, иначе возвращаем пустой массив (В графе есть цикл).



## **Оценка:**

Верхняя граница по времени будет **O**(**V** + **E**), где **V** - количество вершин (**numCourses**), а **E** - количество ребер (**len**(**prerequisites**)). Сложность по времени от **BFS**. По памяти мы получим **O**(**V** + **E**). Так как мы будем хранить граф. Так же память затраченная на массив **in_degree** будет равна **O**(**V**), но мы выбираем наибольшую, поэтому итоговая верхняя граница по времени **O**(**V** + **E**).

## Код:
```python
from collections import defaultdict, deque


class Solution:
    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:
        graph = defaultdict(list)

        in_degree = [0] * numCourses

        for u, v in prerequisites:
            in_degree[u] += 1
            graph[v].append(u)

        queue = deque([x for x in range(numCourses) if in_degree[x] == 0])
        result = []

        while queue:
            vert = queue.popleft()
            result.append(vert)
            for child in graph[vert]:
                in_degree[child] -= 1
                if in_degree[child] == 0:
                    queue.append(child)

        return result if len(result) == numCourses else []


if __name__ == "__main__":
    f = Solution().findOrder
    print(f(2, [[1, 0]]))
    print(f(4, [[1, 0], [2, 0], [3, 1], [3, 2]]))
    print(f(1, []))

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/93.Course%20Schedule'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/95.Snakes%20and%20Ladders'>следующая задача ➡️</a></h3></div>