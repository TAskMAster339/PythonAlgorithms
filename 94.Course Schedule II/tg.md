**94) Course Schedule II**
https://leetcode.com/problems/course-schedule-ii/description/
**Условие:**
Всего есть **numCourses** курсов, которые нужно пройти. Каждый курс имеет свой номер от **0** до **numCourses** - **1**. Дан массив **prerequisites**, где **prerequisites**[**i**] = [**a_i**, **b_i**], означает, что перед тем как пройти курс **b_i**, необходимо пройти **a_i**.
Нужно вернуть порядок курсов, который позволяет пройти все курсы. Если ответов несколько, вернуть можно любой. Если невозможно закончить все курсы, верните пустой массив
**Идея:**
Нужно представить курсы в виде графа и топологически отсортировать его.
Топологическая сортировка - упорядочивание вершин ациклического ориентированного графа согласно частичному порядку, заданному рёбрами ориентированного графа на множестве его вершин.
**Реализация:**
    Для этого воспользуемся алгоритмом Кана. Если граф можно топологически отсортировать, то в нем существует такая вершина, в которую не входит ни одно ребро графа. Алгоритм Кана состоит в том, чтобы найти такую вершину и начать обходить граф в ширину, начиная с неё. Затем исключить эту вершину из графа и начать алгоритм снова над уже новым графом. В конце мы получим список вершин в порядке топологической сортировки нашего графа. 
    Для этого создадим массив **in_degree**, в котором на **i**-том индексе будет храниться количество ребер, входящих в **i**-тую вершину. Если по **i**-тому индексу лежит **0**, то это значит, что в эту вершину не входят ребра. Добавляем её в очередь и начинаем **BFS**.
    Достаем вершину из очереди, добавляем её в **result** и проходим по связными с нею вершинами. Как бы уберем эту вершину из графа, для этого из **in_degree**[**child**] вычтем **1** (Так как вершина пропала, пропало и ребро, входящие в связную с ней вершину). Если значение входящих ребер стало равным **0**, то добавляем вершину в очередь.
    В конце возвращаем **result**, если его длина равна **numCourses**, иначе возвращаем пустой массив (В графе есть цикл).

**Оценка:**
    Верхняя граница по времени будет **O**(**V** + **E**), где **V** - количество вершин (**numCourses**), а **E** - количество ребер (**len**(**prerequisites**)). Сложность по времени от **BFS**. По памяти мы получим **O**(**V** + **E**). Так как мы будем хранить граф. Так же память затраченная на массив **in_degree** будет равна **O**(**V**), но мы выбираем наибольшую, поэтому итоговая верхняя граница по времени **O**(**V** + **E**).
