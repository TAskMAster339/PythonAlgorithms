# [**15) Candy**](https://leetcode.com/problems/candy/description/)

## **Условие:**

Есть **n** детей, которые выстроены в линию. Каждому **i**-тому ребенку присвоен рейтинг **ratings**[**i**], который дан в массиве **ratings**. Нам нужно распределить между детьми минимальное количество конфет, удовлетворяющее следующим условиям: **1**) Каждый ребенок должен получить хотя бы **1** конфету, **2**) Ребенок, у которого рейтинг выше, чем у его соседей, должен получить конфет больше, чем его соседи.

## **Идея:**

Нужно искать возрастающие подпоследовательности, например [**0**, **2**, **17**]. В этой подпоследовательности конфеты будут распределены следующим образом [**1**, **2**, **3**].

## **Реализация:**

Создадим массив **candies**, длиной **len**(**ratings**) и заполним его **1**, тем самым мы удовлетворим **1**) условие задачи.

Теперь сделаем два прохода по массиву **ratings**, один от начала до конца, а другой наоборот. В них мы будем искать возрастающие подпоследовательности, потому что при возрастании приоритетов детей, очевидно возрастает количество конфет, которое необходимо выдавать следующему. Количество конфет, которое должен получить следующий ребенок с большим приоритетом будет равно количеству конфет предыдущего ребенка с более низким приоритетом плюс один, так как нам необходимо найти минимальное количество конфет.

В первом проходе будем сравнивать **ratings**[**i**] > **ratings**[**i** - **1**], если условие выполняется, то мы нашли возрастающую подпоследовательность, присваиваем **candies**[**i**] = **candies**[**i** - **1**] + **1**.

Во втором проходе делаем то же самое, только учитывая две вещи:

Во-первых, идем с конца до начала, находя наши любимые возрастающие подпоследовательности.

Во-вторых, мы присваиваем **candies**[**i**] = **max**(**candies**[**i**], **candies**[**i** + **1**] + **1**). Так как второй цикл идет после первого, то мы уже могли посчитать количество конфет для данного ребенка. Это посчитанное количество конфет можно либо увеличить(на **1**, ибо не забываем, что ищем минимум), либо оставить тем же самым, но ни в коем случае его нельзя уменьшать, потому что первый цикл посчитал такое число, которое удовлетворяет условию **2**) для одного левого соседа, а второй цикл обновляет количество конфет, чтобы удовлетворялось условие **2**) для правого соседа (отсюда следует, что количество конфет **candies**[**i**] при втором проходе, либо не меняется, либо увеличивается на один, оба данных действия гарантируют выполнения условия **2**) для обоих соседей).

Так как мы прибавляли по **1** конфете, и учли все условия, то сумма нашего массива будет представлять минимальное количество конфет, которое распределено между детьми.

## **Оценка:**

Два цикла **for**, каждый имеет **len**(**ratings**) итераций, следовательно затраченное время будет равно **O**(**N**), также нам понадобился массив **candies**, длинной **len**(**ratings**), поэтому расходы по памяти будут **O**(**N**). Кажется, что память можно оптимизировать до **O**(**1**), например, динамически считая сумму конфет, но значение Ω(**N**) является не только верхней асимптотической границей, но и нижней, так как без использования **O**(**N**) дополнительной памяти решение задачи не представляется возможным. Итого точная асимптотическая граница по памяти равна Θ(**N**) так как (**O**(**N**)=Ω(**N**))

## Код:
```python
from typing import List


class Solution:
    def candy(self, ratings: List[int]) -> int:
        candies = [1] * len(ratings)

        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
        print(candies)
        return sum(candies)


if __name__ == "__main__":
    s = Solution()
    print(s.candy([1, 0, 2]))
    print(s.candy([1, 3, 4, 5, 2]))
    print(s.candy([1, 3, 2, 2, 1]))

```

