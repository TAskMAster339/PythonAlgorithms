133) Factorial Trailing Zeroes
https://leetcode.com/problems/factorial-trailing-zeroes/description/
Условие:
Дано число n, нужно вернуть количество количество нулей в числе n!.
При этом n! = n * (n - 1) * ... * 2 * 1
Идея:
Вспомнить от чего зависят 0 на конце числа
Реализация:
    Для того, чтобы получить число с 0 на конце, необходимо взять любое число без 0 на конце и умножить его на 10.
    Представим n! в виде суммы степеней простых чисел (По основной теореме арифметики мы можем так сделать с вообще любым натуральным числом). n! = 2^k * 3^c * 5^h * ...
    Для того, чтобы посчитать количество нулей в конце n!, необходимо посчитать количество пар (2 * 5) = 10, которое получается в результате умножения.
    Заметим, что двоек будет всегда как минимум в 2 раза больше 5. Например, 5! = 5 * 4 * 3 * 2 * 1 = 5^1 * 3^1 * 2^3. <=> 3 > 1
    Поэтому нам необходимо посчитать количество 5 в произведении n!, это и будет наш искомый ответ.
    Для этого будем считать количество 5 следующим образом. Например, возьмем число 127. В числе 127! будет 127 // 5 == 25 чисел, в состав которых входит ровно 1 пятерка. Также в числе 127! будет 127 // 25 == 5 чисел, в которых есть 2 пятерки. Аналогично найдем последнее число 127 // 125 == 1, в котором будет ровно 3 пятерки.
    Таким образом всего нулей на конце числа 127! будет 25 + 5 + 1 = 31.
    В коде я немного оптимизировал решение с помощью следующей идеи: всего в числе 127! есть 25 чисел с пятерками (как минимум 1 есть), в этих 25 числах есть 5 чисел с как минимум двумя пятерками, в этих 5 числах есть как минимум одно число с 3 пятерками. Итого всего есть 25 чисел с 1 пятеркой плюс 5 из них еще имеют 5 новых пятерок и одно из 5 чисел имеет еще одну ранее не посчитанную пятерку, всего 25 + 5 + 1 = 31. (Докажите, почему это работает, сами).

Оценка:
    Сложность по времени будет O(log5 N), где N - данное нам число. Каждый раз мы уменьшаем себе работу в 5 раз, поэтому цикл будет иметь log5 N итераций.
    Сложность по памяти будет O(1).