<div align='center'>
<h1><a href='https://leetcode.com/problems/factorial-trailing-zeroes/description/'><strong>133) Factorial Trailing Zeroes</strong></a></h1>
</div>

## **Условие:**

Дано число **n**, нужно вернуть количество количество нулей в числе **n**!.

При этом **n**! = **n** * (**n** - **1**) * ... * **2** * **1**

## **Идея:**

Вспомнить от чего зависят **0** на конце числа

## **Реализация:**

Для того, чтобы получить число с **0** на конце, необходимо взять любое число без **0** на конце и умножить его на **10**.

Представим **n**! в виде суммы степеней простых чисел (По основной теореме арифметики мы можем так сделать с вообще любым натуральным числом). **n**! = **2**^**k** * **3**^**c** * **5**^**h** * ...

Для того, чтобы посчитать количество нулей в конце **n**!, необходимо посчитать количество пар (**2** * **5**) = **10**, которое получается в результате умножения.

Заметим, что двоек будет всегда как минимум в **2** раза больше **5**. Например, **5**! = **5** * **4** * **3** * **2** * **1** = **5**^**1** * **3**^**1** * **2**^**3**. <=> **3** > **1**

Поэтому нам необходимо посчитать количество **5** в произведении **n**!, это и будет наш искомый ответ.

Для этого будем считать количество **5** следующим образом. Например, возьмем число **127**. В числе **127**! будет **127** // **5** == **25** чисел, в состав которых входит ровно **1** пятерка. Также в числе **127**! будет **127** // **25** == **5** чисел, в которых есть **2** пятерки. Аналогично найдем последнее число **127** // **125** == **1**, в котором будет ровно **3** пятерки.

Таким образом всего нулей на конце числа **127**! будет **25** + **5** + **1** = **31**.

В коде я немного оптимизировал решение с помощью следующей идеи: всего в числе **127**! есть **25** чисел с пятерками (как минимум **1** есть), в этих **25** числах есть **5** чисел с как минимум двумя пятерками, в этих **5** числах есть как минимум одно число с **3** пятерками. Итого всего есть **25** чисел с **1** пятеркой плюс **5** из них еще имеют **5** новых пятерок и одно из **5** чисел имеет еще одну ранее не посчитанную пятерку, всего **25** + **5** + **1** = **31**. (Докажите, почему это работает, сами).



## **Оценка:**

Сложность по времени будет **O**(**log5** **N**), где **N** - данное нам число. Каждый раз мы уменьшаем себе работу в **5** раз, поэтому цикл будет иметь **log5** **N** итераций.

Сложность по памяти будет **O**(**1**).

## Код:
```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n:
            count += n // 5
            n //= 5
        return count


if __name__ == "__main__":
    f = Solution().trailingZeroes
    print(f(3))  # 0
    print(f(5))  # 1
    print(f(0))  # 0
    print(f(25))  # 5
    print(f(127))  # 31

```

<div align='center'><h3><a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/132.Plus%20One'>⬅️ предыдущая задача</a>&nbsp;|&nbsp;<a href='https://github.com/TAskMAster339/PythonAlgorithms/tree/main/README.md'>Все задачи</a></h3></div>