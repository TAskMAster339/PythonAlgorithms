96) Minimum Genetic Mutation
https://leetcode.com/problems/minimum-genetic-mutation/description/
Условие:
Ген может быть представлен в виде строки длины 8, которая состоит из комбинации символов 'A', 'C', 'G', 'T'. Предположим, что нам нужно построить цепочку мутации от гена startGene до гена endGene. Где под мутации понимается изменение ровно одного символа в строке.
Так же дан банк генов bank, в котором записаны все разрешенные мутации.
Необходимо вернуть минимальное количество мутаций, которое необходимо совершить, чтобы мутировать от гена startGene до гена endGene, используя мутации из банка bank. Если мутацию провернуть невозможно, необходимо вернуть -1
Идея:
Подход очевидный, каждый ген представляем как узел графа, а ребро - мутация. Тогда нужно снова найти наикратчайший путь в графе
Реализация:
    Пойдем с помощью BFS. Создадим очередь, в которой будем хранить кортеж из гена и длина мутационного пути до этого гена. Например, в начале добавим (startGene, 0). Также для оптимизации создадим множество visited.
    Реализуем классический BFS. Мы будем перебирать все гены из банка. Условием добавления гена в очередь будет отсутствие гена в visited и возможность мутировать в него из текущего гена. (Для этого создадим вспомогательную функцию, которая просто проверяет, что в двух строках есть ровно один отличный символ)
    Если наш gene из очереди оказался равен endGene, то мы возвращаем длину его мутационного пути.
    Если BFS не нашел путь, то мы возвращаем -1.

Оценка:
    Верхняя граница по времени будет O(N^2), где N - размер банка. (BFS пройдет по всем узлам графа (генам) это O(N) и при этом каждый раз будет итерация по всем генам в банке, которых O(N), поэтому в итоге получим O(N^2)). Асимптотическая оценка по памяти будет O(N). Так как все N элементов банка мы будем хранить, либо в очереди, либо множестве visited.