**29) 3Sum**
https://leetcode.com/problems/3sum/description/
**Условие:**
Дан массив целых чисел **nums**, нужно вернуть массив троек [**nums**[**i**], **nums**[**j**], **nums**[**k**]], таких, что **i** != **j**, **i** != **k** и **nums**[**i**] + **nums**[**j**] + **nums**[**k**] == **0**. Решение не должно содержать дубликатов.
**Идея:**
Сортировка, после чего два указателя
**Реализация:**
    Отсортируем массив с помощью метода .**sort**(), далее в цикле пройдемся по всем числам массива. Нам нужно зафиксировать одно число и найти ему пары. Так как нам не нужны дубликаты, то мы пропускаем одинаковые числа в начале. Когда мы нашли еще нерассмотренное уникальное число, мы создаем два указателя **left** = **i** + **1** и **right** = **len**(**nums**) - **1**. **Eсли** наше число больше **0**, то мы выходим из цикла, так как в отсортированном массиве это значит, что после этого числа не будет никаких других, которые в сумме с ним дадут **0**. 
    Теперь пока **left** < **right**, мы считаем сумму тройки. Если сумма оказалась больше **0**, тогда мы двигаем правый указатель, тем самым мы уменьшим нашу сумму. Если сумма меньше **0**, мы двигаем левый, чтобы увеличить сумму. Как только сумма оказалась равной **0**, то мы добавляем её в массив **res**, который вернем в качестве результата. Затем мы с помощью цикла **while** мы очень быстро двигаем левый указатель, пропуская дубликаты.
    Так как мы фиксируем уникальные числа. Когда находим тройку, мы пропускаем дубликаты. То мы всегда получим уникальные тройки. (Кстати, каждая тройка будет отсортирована по неубыванию).

**Оценка:**
    Цикл делает один проход, но перед этим мы сортируем массив (предположим, что самой быстрой сортировкой сравнением), тратим **O**(**N*****log** **N**) времени на сортировку, поэтому верхняя граница по времени будет **O**(**N*****log** **N**). Дополнительной памяти мы неиспользуем, поэтому затраты по памяти **O**(**1**).
