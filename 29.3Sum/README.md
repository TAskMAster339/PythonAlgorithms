# [**29) 3Sum**](https://leetcode.com/problems/3sum/description/)

## **Условие:**

Дан массив целых чисел **nums**, нужно вернуть массив троек [**nums**[**i**], **nums**[**j**], **nums**[**k**]], таких, что **i** != **j**, **i** != **k** и **nums**[**i**] + **nums**[**j**] + **nums**[**k**] == **0**. Решение не должно содержать дубликатов.

## **Идея:**

Сортировка, после чего два указателя

## **Реализация:**

Отсортируем массив с помощью метода .**sort**(), далее в цикле пройдемся по всем числам массива. Нам нужно зафиксировать одно число и найти ему пары. Так как нам не нужны дубликаты, то мы пропускаем одинаковые числа в начале. Когда мы нашли еще нерассмотренное уникальное число, мы создаем два указателя **left** = **i** + **1** и **right** = **len**(**nums**) - **1**. **Eсли** наше число больше **0**, то мы выходим из цикла, так как в отсортированном массиве это значит, что после этого числа не будет никаких других, которые в сумме с ним дадут **0**.

Теперь пока **left** < **right**, мы считаем сумму тройки. Если сумма оказалась больше **0**, тогда мы двигаем правый указатель, тем самым мы уменьшим нашу сумму. Если сумма меньше **0**, мы двигаем левый, чтобы увеличить сумму. Как только сумма оказалась равной **0**, то мы добавляем её в массив **res**, который вернем в качестве результата. Затем мы с помощью цикла **while** мы очень быстро двигаем левый указатель, пропуская дубликаты.

Так как мы фиксируем уникальные числа. Когда находим тройку, мы пропускаем дубликаты. То мы всегда получим уникальные тройки. (Кстати, каждая тройка будет отсортирована по неубыванию).



## **Оценка:**

Цикл делает один проход, но перед этим мы сортируем массив (предположим, что самой быстрой сортировкой сравнением), тратим **O**(**N*****log** **N**) времени на сортировку, поэтому верхняя граница по времени будет **O**(**N*****log** **N**). Дополнительной памяти мы неиспользуем, поэтому затраты по памяти **O**(**1**).

## Код:
```python
from typing import List


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left = i + 1
            right = len(nums) - 1
            if nums[i] > 0:
                break
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total > 0:
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    while nums[left] == nums[left - 1] and left < right:
                        left += 1
        return res


if __name__ == "__main__":
    s = Solution()
    print(s.threeSum([-1, 0, 1, 2, -1, -4]))
    print(s.threeSum([0, 1, 1]))
    print(s.threeSum([0, 0, 0]))
    print(s.threeSum([3, -2, 1, 0]))  # []
    print(
        s.threeSum([-1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4])
    )  # [[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],
    # [-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]
    print(s.threeSum([-1, 0, 1, 0]))

```

