107) Word Search
https://leetcode.com/problems/word-search/description/
Условие:
Дана доска board размером m x n и строка word, нужно вернуть True, если слово можно составить на доске.
Слово, составленное на доске, - это слово, которое получено соединением соседних ячеек по горизонтали или по вертикали. При этом каждая ячейка используется ровно один раз
Идея:
Уже была такая задача под номером 100), но мы попытаемся оптимизировать его
Реализация:
    Для этого создадим вспомогательную функцию backtrack.
    Крайний случай состоит из двух частей: 1) Когда глубина рекурсии стала равна длине слова. То есть если мы спустились так глубоко, то мы нашли слово, возвращаем True. 2) Если мы получили нету букву или некорректный индекс, то в этом случае мы возвращаем False.
    Рекуррентный случай состоит из вызовов функции backtrack для клеток сверху, снизу, слева, справа. Если хотя бы один из ник возвращает истину, то мы вернем True. (Это можно понять так, мы ищем слово Tree, мы его нашли, если начали с буквы T и рядом с ней найдено слово ree и так далее рекурсивно)
    При этом backtrack заключается в том, что мы будем на время спуска заменять значение board[i][j] == "", при этом не забываем сохранять это значение, чтобы после окончания была возможность совершить откат.
    Осталось пройти по всем клеткам доски и вызвать для каждой нашу функцию. Если хотя бы один вызов вернет True, возвращаем True, иначе в конце возвращаем False.

Оценка:
    Сложность по времени будет O(MN * 4^L), где доска MN - размер доски, а L - длина слова word, 4 - разрешенные направления, так как всего клеток MN и для каждой мы будем вызывать backtrack, сложность которого O(4^L). Хотя оценка это оценка в наихудшем случае, в среднем алгоритм будет намного быстрее за счёт backtracking.
    Сложность по памяти будет O(L) - это расходы на глубину рекурсии.